<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Photons at the center · OceanLight.jl</title><meta name="title" content="Photons at the center · OceanLight.jl"/><meta property="og:title" content="Photons at the center · OceanLight.jl"/><meta property="twitter:title" content="Photons at the center · OceanLight.jl"/><meta name="description" content="Documentation for OceanLight.jl."/><meta property="og:description" content="Documentation for OceanLight.jl."/><meta property="twitter:description" content="Documentation for OceanLight.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">OceanLight.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Quick Start</span><ul><li class="is-active"><a class="tocitem" href>Photons at the center</a><ul class="internal"><li><a class="tocitem" href="#Problem"><span>Problem</span></a></li><li><a class="tocitem" href="#Initial-Condition"><span>Initial Condition</span></a></li><li><a class="tocitem" href="#Initialize-Parameters"><span>Initialize Parameters</span></a></li><li><a class="tocitem" href="#Monte-Carlo-Simulation"><span>Monte Carlo Simulation</span></a></li><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li></ul></li><li><span class="tocitem">Module</span><ul><li><a class="tocitem" href="../../module/Parameters/">Parameters</a></li><li><a class="tocitem" href="../../module/refraction/">Refraction</a></li><li><a class="tocitem" href="../../module/MonteCarlo/">Monte Carlo Simulation</a></li></ul></li><li><span class="tocitem">Simulation</span><ul><li><a class="tocitem" href="../../Simulation/ModelSetup/">Model Setup</a></li><li><a class="tocitem" href="../../Simulation/AirWaveInteract/">Air-Water Interaction</a></li><li><a class="tocitem" href="../../Simulation/WithinWater/">Light within Water</a></li><li><a class="tocitem" href="../../Simulation/Exporting/">Exporting data</a></li></ul></li><li><a class="tocitem" href="../../contribute/">Contributor&#39;s guide</a></li><li><a class="tocitem" href="../../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Quick Start</a></li><li class="is-active"><a href>Photons at the center</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Photons at the center</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/haoboatlab/OceanLight.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/haoboatlab/OceanLight.jl/blob/main/docs/src/QuickStart/Center.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h1><p>In this example, we introduce the <code>OceanLight</code> calculation of downwelling irradiance field underneath the flat surface. The code example here can be directly pasted onto Julia terminal, run through <code>.jl</code> script file, or IJulia notebook. </p><p>First, we import <code>OceanLight</code> packages and another <code>random</code> dependent package, that will be used as a seed to generate random number in the Monte Carlo simulation.</p><pre><code class="language-julia hljs">using OceanLight
using Random</code></pre><h2 id="Problem"><a class="docs-heading-anchor" href="#Problem">Problem</a><a id="Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Problem" title="Permalink"></a></h2><p>In this example, the problem is to calculate the downwelling irradiance field, when the surface is completely flat, and a total of 10,000,000 photons is focused at a single point in the center. Our domain of interest is defined as <span>$x,y \in \left[\mathrm{-10m},\mathrm{10m}\right]$</span>, and <span>$z \in \left[\mathrm{-190m},\mathrm{10m}\right]$</span> in depth, corresponding to a grid resolution of <span>$512 \times 512 \times 200$</span>  points. Periodic boundary conditions are applied at the domain boundaries. The attenuation properties of water are characterized by an absorption coefficient of <span>$a = 0.0196$</span> and scattering coefficient <span>$b = 0.0031$</span>, which corresponding to the optical properties of sea water at wavelength <span>$490 \mathrm{nm}$</span> <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. </p><h2 id="Initial-Condition"><a class="docs-heading-anchor" href="#Initial-Condition">Initial Condition</a><a id="Initial-Condition-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-Condition" title="Permalink"></a></h2><p>OceanLight accesses all input variables in <code>.yml</code> format and stores their values in <code>Param</code> structure.</p><p>All input variables required by OceanLight can be separated into 3 categories:</p><ol><li><strong>Irradiance:</strong> Setting up the dimension of downwelling irradiance field calculation grid. </li><li><strong>Photon:</strong> Number of Photons and optical properties of the water.</li><li><strong>Wave:</strong> Structure of surface wave field. </li></ol><pre><code class="language-julia hljs"># irradiance
nz = 200                    # Number of total grid point in z direction
dz = 1                      # Physical length of grid spacing in z direction
nxe = 512                   # Number of grid point of the calculation grid in x direction
nye = 512                   # Number of grid point of the calculation grid in y direction
num = 31                    # Constant value (number of angle measurement in Kirk,1981)
ztop = 10                   # Number of grid point in air phase in z direction
# photon
nphoton = 10000000          # Number of photons being generated at each grid point
kr = 10                     # Dummy variable (in developement, not being used)
nxp = 512                   # Number of grid points in x direction where photon can be emitted
kbc = 0                     # Binary value 0 and 1 depending on Boundary condition being implemented
b = 0.0031                  # Scattering coefficient
nyp = 512                   # Number of grid points in x direction where photon can be emitted
a = 0.0196                  # Absorbtance coefficient
# wave
pey = 2*pi/20.0             # Lowest wavenumber that can be captured during the derivative of surface elevation in x direction
nxeta = 512                 # Number of surface elevation grid point in x direction
nyeta = 512                 # Number of surface elevation grid point in y direction
pex = 2*pi/20.0             # Lowest wavenumber that can be captured during the derivative of surface elevation in y direction</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.3141592653589793</code></pre><p><strong>NOTE:</strong> <code>num</code> must be set to a constant value of 31 (number of angle measurement in Kirk, 1981 <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>). <code>kbc</code> accepts only binary values (0 or 1), representing periodic boundary conditions. In contrast to grid spacing <code>dz</code> in z-direction, the grid spacings in the x- and y-directions (<code>dx</code> and <code>dy</code>) are calculated automatically by <code>OceanLight.readparams</code>,  using the formulas <span>$dx \times nxe  = \frac{2\pi}{pex}$</span>, and <span>$dy \times nye = \frac{2\pi}{pey}$</span>. For more detail on all parameters  used, see <a href="../../Simulation/ModelSetup/#simulation_parameters"><code>Simulation parameters</code></a>. </p><p>To create a input variable file suitable for this package, user can either create a new file in <code>.yml</code> format, copy, and paste the code block above, or using a build-in function <code>OceanLight.writeparams</code> to automate the process. </p><p>The function <code>OceanLight.writeparams</code> converts the dictionary of input variables into the <code>light.yml</code> file. </p><pre><code class="language-julia hljs">data=Dict(&quot;irradiance&quot;=&gt;Dict(&quot;nxe&quot;=&gt;nxe,&quot;nye&quot;=&gt;nye,&quot;nz&quot;=&gt;nz,&quot;dz&quot;=&gt;dz,&quot;ztop&quot;=&gt;ztop,&quot;num&quot;=&gt;num),
            &quot;wave&quot;=&gt;Dict(&quot;pex&quot;=&gt;pex,&quot;pey&quot;=&gt;pey,&quot;nxeta&quot;=&gt;nxeta,&quot;nyeta&quot;=&gt;nyeta),
            &quot;photon&quot;=&gt;Dict(&quot;nxp&quot;=&gt;nxp,&quot;nyp&quot;=&gt;nyp,&quot;nphoton&quot;=&gt;nphoton,&quot;a&quot;=&gt;a,&quot;b&quot;=&gt;b,&quot;kr&quot;=&gt;kr,&quot;kbc&quot;=&gt;kbc))

OceanLight.writeparams(data)</code></pre><p>Once the input variable file is generated, this package calculates other related variables and stores all values in the <code>Param</code> structure, through <code>OceanLight.readparams</code>. The default input variable file name that will be read is <code>light.yml</code>, but can be specified by users. In this case, we store <code>Param</code> structure in variable <code>p</code>. </p><pre><code class="language-julia hljs">p = OceanLight.readparams()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Param(513, 513, 512, 512, 31, 200, [0.0, 0.0390625, 0.078125, 0.1171875, 0.15625, 0.1953125, 0.234375, 0.2734375, 0.3125, 0.3515625  …  19.6484375, 19.6875, 19.7265625, 19.765625, 19.8046875, 19.84375, 19.8828125, 19.921875, 19.9609375, 20.0], [0.0, 0.0390625, 0.078125, 0.1171875, 0.15625, 0.1953125, 0.234375, 0.2734375, 0.3125, 0.3515625  …  19.6484375, 19.6875, 19.7265625, 19.765625, 19.8046875, 19.84375, 19.8828125, 19.921875, 19.9609375, 20.0], [9.0, 8.0, 7.0, 6.0, 5.0, 4.0, 3.0, 2.0, 1.0, 0.0  …  -181.0, -182.0, -183.0, -184.0, -185.0, -186.0, -187.0, -188.0, -189.0, -190.0], 0.3141592653589793, 0.3141592653589793, 0.0390625, 0.0390625, 1.0, 10.0, 0.0, 20.0, 0.0, 20.0, 20.0, 20.0, 513, 513, 512, 512, 512, 512, 10000000, 0, 0.0196, 0.0031, 10.0, 0.0390625, 0.0390625)</code></pre><h2 id="Initialize-Parameters"><a class="docs-heading-anchor" href="#Initialize-Parameters">Initialize Parameters</a><a id="Initialize-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-Parameters" title="Permalink"></a></h2><p>Before the simulation, user needs to declare and initialize all parameters and their dimensions. </p><p>During the light refraction between two mediums (air and water) calculation, <code>OceanLight</code> requires the surface elevation attribution: <span>$\eta$</span>; surface elevation, <span>$\eta_{x}$</span>; partial derivative of <span>$\eta$</span> in x direction, and <span>$\eta_{y}$</span>; partial derivative of <span>$\eta$</span> in y direction. All surface elevation distribution, as specified above, need to have the same dimension with the incoming photons&#39; grid. Hence, </p><pre><code class="language-julia hljs">η = zeros(p.nxs,p.nys)
ηx = zeros(p.nxs,p.nys)
ηy = zeros(p.nxs,p.nys)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">513×513 Matrix{Float64}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 ⋮                        ⋮              ⋱                      ⋮         
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre><p>After photons&#39; interaction with the surface, OceanLight requires the information of specific coordinate of photon in cartesian grid <span>${xpb,ypb,zpb}$</span>, the direction in which photon will travel in polar coordinate <span>${θ,ϕ}$</span>, and the fraction of light that transmit through the water <span>${fres}$</span>: all in the dimension of incoming photon grid size. </p><pre><code class="language-julia hljs">xpb = zeros(p.nxp,p.nyp);
ypb = zeros(p.nxp,p.nyp);
zpb = zeros(p.nxp,p.nyp);
θ = zeros(p.nxp,p.nyp);
ϕ = zeros(p.nxp,p.nyp);
fres = zeros(p.nxp,p.nyp);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">512×512 Matrix{Float64}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 ⋮                        ⋮              ⋱  ⋮                        ⋮    
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre><p>During the air-water interaction process, OceanLight simulates the photons transfer directly downward from the air side, interacts with the water surface, and transfer down into water medium. </p><p>User can generate random surface elevation attribution <span>$\{\eta,\eta_{x},\eta_{y}\}$</span> with <code>OceanLight.setwave!</code>, or provided specific data <span>$\{\eta_{0},\eta_{x0},\eta_{y0}\}$</span>  . OceanLight can map the user&#39;s provided data of <span>$\{\eta_{0},\eta_{x0},\eta_{y0}\}$</span>, which might have different dimension onto the suitable dimension of input value <span>$\{η,ηx,ηy\}$</span> with <code>OceanLight.convertwave!</code>.</p><p>In this example, we will consider the case of flat surface elevation. Hence, <span>$\{η,ηx,ηy\}$</span> is equal to the matrix of zeros. </p><p>Once all the input variables are in place, <code>OceanLight.interface!</code> calculate the refraction of the light between two medium given surface elevation attribution and return the position, reflectance angle, and transmission ratio. </p><pre><code class="language-julia hljs">OceanLight.interface!(xpb,ypb,zpb,θ,ϕ,fres,η,ηx,ηy,p)</code></pre><p><code>OceanLight</code> tracks the path of each photon travelling inside the water medium and store the irradiance value in the grid <code>ed</code>. </p><p>Users need to specify these variables and corresponding dimension. </p><pre><code class="language-julia hljs">ed = zeros(p.nx, p.ny, p.nz)
esol = zeros(p.num, p.nz)
randrng = MersenneTwister(1234)
area = zeros(4)
interi = zeros(Int64,4)
interj = zeros(Int64,4)
ix = div(p.nxη,2)+1
iy = div(p.nyη,2)+1
ϕps,θps = OceanLight.phasePetzold()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.517, 0.666, 0.751, 0.811, 0.851, 0.879, 0.901, 0.918, 0.931, 0.942  …  0.995, 0.996, 0.9968, 0.9976, 0.9982, 0.9988, 0.9992, 0.9997, 0.9998, 1.0], [0.04363323129985824, 0.1308996938995747, 0.2181661564992912, 0.30543261909900765, 0.39269908169872414, 0.4799655442984406, 0.5672320068981571, 0.6544984694978736, 0.7417649320975901, 0.8290313946973066  …  2.3125612588924866, 2.399827721492203, 2.48709418409192, 2.5743606466916362, 2.6616271092913526, 2.748893571891069, 2.8361600344907854, 2.9234264970905017, 3.0106929596902186, 3.097959422289935])</code></pre><h2 id="Monte-Carlo-Simulation"><a class="docs-heading-anchor" href="#Monte-Carlo-Simulation">Monte Carlo Simulation</a><a id="Monte-Carlo-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Monte-Carlo-Simulation" title="Permalink"></a></h2><p><code>OceanLight</code> simulates the photon traveling inside the water medium, given its initial position <span>$\{xpb,ypb,zpb\}$</span> and the direction it started with<span>$\{θ,ϕ\}$</span>. Once photons are inside the water, <code>OceanLight</code> will track its path, governed by its probability distribution and the attenuated coefficient input, and store the irradiance value in the grid <code>ed</code>. </p><p>The <code>transfer!</code> function simulate a single photon path and store its landed position on the grid <code>ed</code>. Hence, to simulate multiple photons, users need to loop the <code>transfer!</code> function and giving the input of an individual photon&#39;s number <code>ip</code>. Thus, <code>OceanLight</code> could facilitate parallel computation. </p><pre><code class="language-julia hljs">for ip = 1:p.nphoton
    OceanLight.transfer!(ed,esol,θ[ix,iy],ϕ[ix,iy],fres[ix,iy],ip,xpb[ix,iy],
        ypb[ix,iy],zpb[ix,iy],area,interi,interj,randrng,η,ϕps,θps,p,1)
end</code></pre><p>Lastly, once the field <code>ed</code> is obtained. The <code>applybc!</code> apply and ensure the boundary condition of the <code>ed</code>. </p><pre><code class="language-julia hljs">OceanLight.applybc!(ed,p)</code></pre><p>Once the simulation is over, the downwelling irradiance field <span>$I(x,y,z)$</span> is stored in variable <code>ed</code>. To export the data, the build-in function <code>OceanLight.exported</code> export data and its statistical information in to <code>.h5</code> format, depended on the path given by user. </p><p>The result downwelling irradiance field <span>$I(x,y,z)$</span> is in 3 dimension tensor, where the first two dimensions represent horizontal field, and the last represents the vertical field or depth. The first few depth layer represents the air phase, hence <span>$I(x,y,z)$</span> is zeros, depending on how many layer specified as air phases <code>ztop</code>. To visualize using <code>Plots</code> julia package, users can try the example code below. </p><p>First, the irradiance field <span>$I(x,y,z)$</span> is normalized by its maximum value <span>$I_{0}$</span>. To prevent undefined values <code>NaN</code> during logarithmic scaling, all zero-valued grid points are replaced with its minimum value.</p><pre><code class="language-julia hljs">max_val, max_loc = findmax(ed)
ed = ed./max_val
nonzero_vals = ed[ed .!= 0]
min_val = minimum(nonzero_vals)

for i in 1:Int(nxe+1)
    for j in 1:Int(nye+1)
        for k in ztop:nz
            if ed[i,j,k] == 0
                ed[i,j,k] = min_val
            end
        end
    end
end</code></pre><pre><code class="language-julia hljs">using Plots
using Plots.Measures

# Choose slice indices
iy_c = 256   # y-index for vertical cross-section
iz_a = 40    # z-index for panel (a)
iz_b = 160   # z-index for panel (b)

# Define layout: 2 rows, 2 columns, but right column spans both rows
l = @layout [grid(2,1) c]

# Panel (a) : z = iz_a
p1 = heatmap(
    p.x .-10, p.y .-10, log.(ed[:,:,iz_a]),
    clim=(-20,-7), framestyle=:box, grid=false,
    c=cgrad(:viridis), legend=:none,
    xlabel=&quot;\$x(m)\$&quot;, ylabel=&quot;\$y(m)\$&quot;,
    title=&quot;(a) z = $(round(p.z[iz_a], digits=1)) m&quot;,
    xlim=[minimum(p.x).-10, maximum(p.x).-10],
    ylim=[minimum(p.y).-10, maximum(p.y).-10])
plot!(p1, [minimum(p.x).-10, maximum(p.x).-10], [p.y[iy_c]-10, p.y[iy_c]-10],
      color=:red, lw=2, ls=:dash, alpha=0.6)

# Panel (b) : z = iz_b
p2 = heatmap(
    p.x .-10, p.y .-10, log.(ed[:,:,iz_b]),
    clim=(-20,-7), framestyle=:box, grid=false,
    c=cgrad(:viridis), legend=:none,
    xlabel=&quot;\$x(m)\$&quot;, ylabel=&quot;\$y(m)\$&quot;,
    title=&quot;(b) z = $(round(p.z[iz_b], digits=1)) m&quot;,
    xlim=[minimum(p.x).-10, maximum(p.x).-10],
    ylim=[minimum(p.y).-10, maximum(p.y).-10])
plot!(p2, [minimum(p.x).-10, maximum(p.x).-10], [p.y[iy_c]-10, p.y[iy_c]-10],
      color=:red, lw=2, ls=:dash, alpha=0.6)

# Panel (c) : vertical cross-section at y = iy_c
p3 = heatmap(
    p.x .-10, reverse(p.z), reverse(transpose(log.(ed[:,iy_c,:]))),
    clim=(-20,-7), framestyle=:box, grid=false,
    c=cgrad(:viridis), ylim=(-(nz*dz-10),0),
    xlabel=&quot;\$x(m)\$&quot;, ylabel=&quot;\$z(m)\$&quot;,
    cbar_title=&quot;\$\\ln\\frac{I(x,y,z)}{I_{0}}\$&quot;,
    title=&quot;(c) y = $(round(p.y[iy_c]-10, digits=1)) m&quot;,
    xlim=[minimum(p.x).-10, maximum(p.x).-10])

# Add horizontal lines for z = iz_a, iz_b
plot!(p3, [minimum(p.x).-10, maximum(p.x).-10], [p.z[iz_a], p.z[iz_a]],
      color=:red, lw=1.5, ls=:dash, label=&quot;&quot;, alpha=0.6)
plot!(p3, [minimum(p.x).-10, maximum(p.x).-10], [p.z[iz_b], p.z[iz_b]],
      color=:red, lw=1.5, ls=:dash, label=&quot;&quot;, alpha=0.6)

# Combine
plot(p1, p2, p3, layout=l,
     size=(900,700),
     titleloc=:left, titlefont=font(8),
     left_margin=10mm, right_margin=10mm)</code></pre><img src="6a3881d7.svg" alt="Example block output"/><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Smith, R. C., &amp; Baker, K. S. (1981). Optical properties of the clearest natural waters (200-800 nm). Applied optics, 20(2), 177–184. https://doi.org/10.1364/AO.20.000177 </li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Kirk, J. T. O. (1981). Monte Carlo procedure for simulating the penetration of light into natural waters. In Technical paper - Commonwealth Scientific and Industrial Research Organization (Vol. 36).</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../../module/Parameters/">Parameters »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 15 October 2025 18:46">Wednesday 15 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
