var documenterSearchIndex = {"docs":
[{"location":"module/refraction/#Refraction","page":"Refraction","title":"Refraction","text":"","category":"section"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"To calculate the refraction of the photons between two medium: air and water, OceanLight.jl expands the Snell's Law into three dimension spherical coordinate, with theta_t denotes the transmission angle beneath the surface, and varphi denotes the azimuth angle. In addition to the photons' path, OceanLight.jl calculates the fraction of light that is being reflected back to the air side, via Fresnel reflectance. ","category":"page"},{"location":"module/refraction/#Snell's-Law","page":"Refraction","title":"Snell's Law","text":"","category":"section"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"The angle of reflection describes through the vector analysis, [1]","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"theta_r = cos^-1hatxicdothatn","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"When our incoming photon is directly downward: hatxi=beginbmatrix001endbmatrix and the normal vector can be defined by hatn=dfrac1sqrt1+left(eta_xright)^2+left(eta_yright)^2left(-eta_xhati-eta_yhatj+hatkright) When, eta_x is the partial derivative the partial derivative of eta with respect to x: dfracpartialetapartial x and eta_y is the partial derivative the partial derivative of eta with respect to y: dfracpartialetapartial y","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"Therefore, the angle of reflection, in this module, can be described by ","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"theta_r = cos^-1left(frac1sqrt1+left(eta_xright)^2+left(eta_yright)^2right)","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"The angle of transmission can be described by Snell's Law,","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"theta_t = sin^-1left(frac1n_wsintheta_rright)","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"Substitute the theta_r that we found above. ","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"theta_t = sin^-1left(frac1n_wsqrtfracleft(eta_xright)^2+left(eta_yright)^21+left(eta_xright)^2+left(eta_yright)^2right)","category":"page"},{"location":"module/refraction/#Fresnel-reflectance","page":"Refraction","title":"Fresnel reflectance","text":"","category":"section"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"In our package, we calculate the energy proportion of the light ray that being transmitted to the water, but first we identify the amplitude transmission coefficient or the ratio between electric field amplitude of the transmitted light ray to the intirial light ray. [2]","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"t_perp = left(fracE_tE_0right)_perp = frac2sin(theta_t)cos(theta_r)sin(theta_t+theta_r)","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"t_parallel = left(fracE_tE_0right)_parallel = frac2sin(theta_t)cos(theta_r)sin(theta_t+theta_r)cos(theta_r-theta_t)","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"When t_perp is corresponding to the amplitude transmission coefficient of the light ray in which the electric field, that constitute the electro magnetic wave, perpendicular to the plane-of-incident , and t_parallel is corresponding to the amplitude transmission coefficient of the light ray in which the electric field, that constitute the electro magnetic wave, parallels to the plane-of-incident.","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"The intensity of the light is proportional to the square of the amplitude, I propto E^2.  All conceivable azimuths of waves that are polarized combine to form natural or unpolarized light. Each wave can be broken down into its constituent parts. Each component will have an equal amount due to symmetry. Then, half of the amplitude transmission coefficient yields the transmission coefficient of a surface in natural light. [3]","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"t = fracI_tI_0 = frac12leftleftfrac2sin(theta_t)cos(theta_r)sin(theta_r+theta_t)right^2+leftfrac2sin(theta_t)cos(theta_r)sin(theta_r+theta_t)cos(theta_r-theta_t)right^2right","category":"page"},{"location":"module/refraction/#Result","page":"Refraction","title":"Result","text":"","category":"section"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"From the principle of least time, the path in which light travels is the path that can traveled in the least time. Hence, the incident, transmitted light ray, and the normal vector to the water surface lie in the same plane. The normal vector to the plane can be described by the cross product between incident light ray and normal vector to the water surface. When the light ray travels downward, along the z-axis, the z-axis lies on the plane, and hence, the plane is perpendicular to the xy plane. The transmitted light ray lies on the opposite side of the normal vector to the water surface. The normal vector to the water surface can be described by, hatn_xy=frac1sqrteta_x^2+eta_y^2beginbmatrix-eta_x-eta_y0endbmatrix`, and the angle of this vector to the x-axis is, ","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"phi = arccosfraceta_xsqrt(eta_x)^2+(eta_y)^2","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"The range for arccos function is 0pi, however, our expected azimuthal angle can span from 02pi. Hence, in order to find the azimuthal angle of the transmitted light ray, we need to consider every possible case of eta_x and eta_y.","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"When eta_x is equal to zero, the possible value for phi is either fracpi2 or frac3pi2, and the value would be determined by eta_y.","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"When eta_y is positive, the normal vector to the water surface hatn lies on either the first or second quadrant, and the azimuthal angle of transmitted light ray would lie on either third or fourth qudrant. Therfore, ","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"varphi = pi+arccosfraceta_xsqrt(eta_x)^2+(eta_y)^2","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"When eta_y is negative, the normal vector to the water surface hatn lies on either the third or fourth quadrant, and the azimuthal angle of transmitted light ray would lie on either first or second qudrant. Therfore, ","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"varphi = pi-arccosfraceta_xsqrt(eta_x)^2+(eta_y)^2","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"The result azimuthal angle of transmitted ray can be described by,","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"varphi = left\nbeginarrayll\npi+arccosleft(fraceta_xsqrt(eta_x)^2+(eta_y)^2right)  textfor  eta_y  0 10pt\npi-arccosleft(fraceta_xsqrt(eta_x)^2+(eta_y)^2right)  textfor  eta_y  0\nendarray\nright","category":"page"},{"location":"module/refraction/#Reference","page":"Refraction","title":"Reference","text":"","category":"section"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"[1]: Mobley, C. (1994). Across the Surface. Light and Water: Radiative Transfer in Natural Waters (pp. 155-157). Academic Press. ","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"[2]: Hecht, E. (2001). The Propagation of Light. Optics (pp. 113-115). Addison-Wesley. ","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"[3]: Sears, F.W. (1949). Polarization Optics (pp. 173-174). Addison-Wesley","category":"page"},{"location":"Simulation/AirWaveInteract/#Air-water-interaction","page":"Air-Water Interaction","title":"Air-water interaction","text":"","category":"section"},{"location":"Simulation/AirWaveInteract/","page":"Air-Water Interaction","title":"Air-Water Interaction","text":"This section describes the function that can be used for the light interaction between the atmosphere and water. This section can be skipped entirely, if the simulation only considered the light within the water medium.","category":"page"},{"location":"Simulation/AirWaveInteract/","page":"Air-Water Interaction","title":"Air-Water Interaction","text":"To setup the stage for light refraction, the data of water surface distribution is needed: water elevation eta, the slope in x direction eta_x = fracpartial etapartial x and y direction eta_y = fracpartial etapartial y. OceanLight.jl offers random wave distribution or input in .h5 format. ","category":"page"},{"location":"Simulation/AirWaveInteract/#Setting-random-water-surface-distribution","page":"Air-Water Interaction","title":"Setting random water surface distribution","text":"","category":"section"},{"location":"Simulation/AirWaveInteract/","page":"Air-Water Interaction","title":"Air-Water Interaction","text":"setwave!(η::Array{<:Float64,2},ηx::Array{<:Float64,2},ηy::Array{<:Float64,2},rms::Float64,p::Param)","category":"page"},{"location":"Simulation/AirWaveInteract/#OceanLight.setwave!-Tuple{Matrix{<:Float64}, Matrix{<:Float64}, Matrix{<:Float64}, Float64, Param}","page":"Air-Water Interaction","title":"OceanLight.setwave!","text":"setwave!(η::Array{<:Float64,2},ηx::Array{<:Float64,2},ηy::Array{<:Float64,2},rms::Float64,p::Param)\n\nGiving the value to the existed wave surface distribution grid\n\nArguments\n\nη::Array{<:Float64,2}: water surface elevation.\nηx::Array{<:Float64,2}: partial derivative of water surface elevation in x direction.\nηy::Array{<:Float64,2}: partial derivative of water surface elevation in y direction.\nrms::Float64: random number.\np::Param: simulation parameters.\n\n\n\n\n\n","category":"method"},{"location":"Simulation/AirWaveInteract/#Importing-water-surface-distribution-data","page":"Air-Water Interaction","title":"Importing water surface distribution data","text":"","category":"section"},{"location":"Simulation/AirWaveInteract/","page":"Air-Water Interaction","title":"Air-Water Interaction","text":"readdata(datdir::String,fname::String,n::Tuple{<:Int64,<:Int64},pexy::Tuple{<:Float64,<:Float64})","category":"page"},{"location":"Simulation/AirWaveInteract/#OceanLight.readdata-Tuple{String, String, Tuple{Int64, Int64}, Tuple{Float64, Float64}}","page":"Air-Water Interaction","title":"OceanLight.readdata","text":"readdata(datdir::String,fname::String,n::Tuple{<:Int64,<:Int64},pexy::Tuple{<:Float64,<:Float64})\n\nReading the wave surface distribution data (surface elevation η and partial derivative of it in x and y ηx and ηy) from the .h5 file, given the directory datdir and the file name fname\n\n\n\n\n\n","category":"method"},{"location":"Simulation/AirWaveInteract/","page":"Air-Water Interaction","title":"Air-Water Interaction","text":"The water surface distribution data may or may not match the input irradiance field. Hece, OceanLight.jl interpolates the value eta, eta_x, and eta_y, to match the corresponding irradiance field. ","category":"page"},{"location":"Simulation/AirWaveInteract/","page":"Air-Water Interaction","title":"Air-Water Interaction","text":"convertwave!(η::Array{<:Float64,2},ηx::Array{<:Float64,2},ηy::Array{<:Float64,2},\n                      η0::Array{<:AbstractFloat,2},ηx0::Array{<:AbstractFloat,2},ηy0::Array{<:AbstractFloat,2},kbc=0::Int64)","category":"page"},{"location":"Simulation/AirWaveInteract/#OceanLight.convertwave!","page":"Air-Water Interaction","title":"OceanLight.convertwave!","text":"convertwave!(η, ηx, ηy, η0, ηx0, ηy0, kbc)\n\nConvert the surface wave geometry η0, ηx0, ηy0 to  η, ηx, ηy with the same size as irradiance field.  Can be used for nonperiodic BCkbc=1 (no interpolation) or periodic BC kbc=0 (interpolation using FFT)\n\n\n\n\n\n","category":"function"},{"location":"Simulation/AirWaveInteract/#Refraction","page":"Air-Water Interaction","title":"Refraction","text":"","category":"section"},{"location":"Simulation/AirWaveInteract/","page":"Air-Water Interaction","title":"Air-Water Interaction","text":"interface!(xpb::Array{<:Float64,2},ypb::Array{<:Float64,2},zpb::Array{<:Float64,2},\n                    θ::Array{<:Float64,2},ϕ::Array{<:Float64,2},fres::Array{<:Float64,2},\n                    η::Array{<:Float64,2},ηx::Array{<:Float64,2},ηy::Array{<:Float64,2},p::Param)","category":"page"},{"location":"Simulation/AirWaveInteract/#OceanLight.interface!-Tuple{Matrix{<:Float64}, Matrix{<:Float64}, Matrix{<:Float64}, Matrix{<:Float64}, Matrix{<:Float64}, Matrix{<:Float64}, Matrix{<:Float64}, Matrix{<:Float64}, Matrix{<:Float64}, Param}","page":"Air-Water Interaction","title":"OceanLight.interface!","text":"interface!(xpb::Array{<:Float64,2},ypb::Array{<:Float64,2},zpb::Array{<:Float64,2},\n                θ::Array{<:Float64,2},ϕ::Array{<:Float64,2},fres::Array{<:Float64,2},\n                η::Array{<:Float64,2},ηx::Array{<:Float64,2},ηy::Array{<:Float64,2},p::Param)\n\nCalculate the reflection and refraction of the photon or light ray that transmit from the atmosphere to the water.\n\nArguments\n\nxpb::Array{<:Float64,2}: initial x coordination of the photon.\nypb::Array{<:Float64,2}: initial y coordination of the photon.\nzpb::Array{<:Float64,2}: initial z coordination of the photon.\nθ::Array{<:Float64,2}: angle of the light ray relative to the z axis: polar angle.\nϕ::Array{<:Float64,2}: angle of the light ray relative to the x axis: azimuthal angle.\nfres::Array{<:Float64,2}: fresnel coefficient or fractional transmission for unpolarized light\nη::Array{<:Float64,2}: water surface elevation.\nηx::Array{<:Float64,2}: partial derivative of water surface elevation in x direction.\nηy::Array{<:Float64,2}: partial derivative of water surface elevation in y direction.\np::Param: simulation parameters.\n\n\n\n\n\n","category":"method"},{"location":"Simulation/ModelSetup/#Model-setup","page":"Model Setup","title":"Model setup","text":"","category":"section"},{"location":"Simulation/ModelSetup/","page":"Model Setup","title":"Model Setup","text":"OceanLight.jl simulation reads all required variable from the struct param. The description on how to generate and setup the model is described below in this section.  ","category":"page"},{"location":"Simulation/ModelSetup/#Input-variable","page":"Model Setup","title":"Input variable","text":"","category":"section"},{"location":"Simulation/ModelSetup/","page":"Model Setup","title":"Model Setup","text":"OceanLight.jl accepts and reads the input variables from .yml file. The structure on what variable to includes is shown below. ","category":"page"},{"location":"Simulation/ModelSetup/","page":"Model Setup","title":"Model Setup","text":"writeparams(data::Dict,fname=\"light.yml\"::String)","category":"page"},{"location":"Simulation/ModelSetup/#OceanLight.writeparams","page":"Model Setup","title":"OceanLight.writeparams","text":"writeparams(data::Dict,fname=\"light.yml\"::String)\n\nReplace the data in the yml file fname to the new dictionary data. \n\nIf fname is unspecified, use light.yml as the default file name.\n\n\n\n\n\n","category":"function"},{"location":"Simulation/ModelSetup/","page":"Model Setup","title":"Model Setup","text":"This function only read the dict format. Hence, we first need to rearrange into dict format, before we can called the function writeparams(). ","category":"page"},{"location":"Simulation/ModelSetup/","page":"Model Setup","title":"Model Setup","text":"# irradiance\nnz = 200\ndz = 1\nnxe = 512\nnye = 512\nnum = 31\nztop = 10\n# photon\nnphoton = 100000\nkr = 10\nnxp = 512\nkbc = 0\nb = 0.006\nnyp = 512\na = 0.007\n# wave\npey = 0.07853981633974483\nnxeta = 512\nnyeta = 512\npex = 0.07853981633974483\n\ndata=Dict(\"irradiance\"=>Dict(\"nxe\"=>nxe,\"nye\"=>nye,\"nz\"=>nz,\"dz\"=>dz,\"ztop\"=>ztop,\"num\"=>num),\n            \"wave\"=>Dict(\"pex\"=>pex,\"pey\"=>pey,\"nxeta\"=>nxeta,\"nyeta\"=>nyeta),\n            \"photon\"=>Dict(\"nxp\"=>nxp,\"nyp\"=>nyp,\"nphoton\"=>nphoton,\"a\"=>a,\"b\"=>b,\"kr\"=>kr,\"kbc\"=>kbc))","category":"page"},{"location":"Simulation/ModelSetup/#simulation_parameters","page":"Model Setup","title":"Simulation parameters","text":"","category":"section"},{"location":"Simulation/ModelSetup/","page":"Model Setup","title":"Model Setup","text":"OceanLight.jl reads all input variables in .yml format through the function readparams(), and store the values in structure Param. Beside our provided value, it will auto-generate some of the parameters that will be used in the simulation. The list and description of all the values can be accessed below. ","category":"page"},{"location":"Simulation/ModelSetup/","page":"Model Setup","title":"Model Setup","text":"readparams(fname=\"light.yml\"::String)","category":"page"},{"location":"Simulation/ModelSetup/#OceanLight.readparams","page":"Model Setup","title":"OceanLight.readparams","text":"readparams(fname=\"light.yml\")\n\nRead parameters from yml file fname. \n\nIf fname is unspecified, use light.yml as the default file name.\n\n\n\n\n\n","category":"function"},{"location":"Simulation/ModelSetup/","page":"Model Setup","title":"Model Setup","text":"Param    ","category":"page"},{"location":"Simulation/ModelSetup/#OceanLight.Param","page":"Model Setup","title":"OceanLight.Param","text":"struct Param\n\nAll the Parameters and their attributes that will be used in the simulation\n\nnx::Int64: nx = nxe+1 , nxe is the number of energy grid that we will calculate for the energy in x direction\nny::Int64: ny = nye+1 , nye is the number of energy grid that we will calculate for the energy in y direction\nnxe::Int64: number of energy grid that we will calculate for the energy in x direction\nnye::Int64: number of energy grid that we will calculate for the energy in y direction\nnum::Int64: constant always set at 31 based on Measurement from Kirk, 1981 (The number of angle measurement in Kirk paper)\nnz::Int64: number of the layer beneath the sea surface (in z direction) that we will calculate for the irradiance energy\nx::Vector{Float64}: array of all the x corrdination\ny::Vector{Float64}: array of all the y cooradination\nz::Vector{Float64}: array of all the z coordination\npex::Float64: pex is being used in function pdfx or the function to calculate the partial derivative of the surface elevation in x direction\npey::Float64: pey is being used in function pdfx or the function to calculate the partial derivative of the surface elevation in y direction\ndx::Float64: the distance between each grid point in x direction\ndy::Float64: the distance between each grid point in y direction\ndz::Float64: height difference between each layer that we calculate for the irradiance energy (nz)\nztop::Float64: the maximum height above the water surface\nxmin::Float64: minimum x value (always set to 0)\nxmax::Float64: maximum x value equal to multiplication between total number of grid point (nxe) and the distance between each grid point (dx) in x direction\nymin::Float64: minimum y value (always set to 0)\nymax::Float64: maximum y value equal to multiplication between total number of grid point (nye) and the distance between each grid point (dy) in y direction\nxl::Float64: difference between the maximum and minimum value in x direction\nyl::Float64: difference between the maximum and minimum value in y direction\nnxs::Int64: nxs=nxη+1\nnys::Int64: nys=nyη+1\nnxη::Int64: same as nxeta value in the light.yml file: the number of wave grid point in x direction\nnyη::Int64: same as nyeta value in the light.yml file: the number of wave grid point in y direction\nnxp::Int64: number of grid in x direction that the photon will be emitted\nnyp::Int64: number of grid in y direction that the photon will be emitted\nnphoton::Int64: number of photon emitted\nkbc::Int64: setting the mode of boundary condition: kbc=1 (no interpolation) or periodic BC kbc=0 (interpolation using FFT)\na::Float64: absortance coefficient\nb::Float64: scattering coefficient\nkr::Float64: the multiple of sphere detector radius to dz (not being used anywhere in the code)\nddx::Float64: the distance difference in x direction in which we will emit the photon (total length of physical grid xl devided by total number of photon grid nxp)\nddy::Float64: the distance difference in y direction in which we will emit the photon (total length of physical grid yl devided by total number of photon grid nyp)\n\n\n\n\n\n","category":"type"},{"location":"Simulation/WithinWater/#Light-within-water","page":"Light within Water","title":"Light within water","text":"","category":"section"},{"location":"Simulation/WithinWater/","page":"Light within Water","title":"Light within Water","text":"In OceanLight.jl simulation, the scattering photons inside the water medium using the distribution based on Petzold(1972,) in which the value need to be called manually and stored in the variable ph and θps. ","category":"page"},{"location":"Simulation/WithinWater/","page":"Light within Water","title":"Light within Water","text":"phasePetzold()","category":"page"},{"location":"Simulation/WithinWater/#OceanLight.phasePetzold-Tuple{}","page":"Light within Water","title":"OceanLight.phasePetzold","text":"phasePetzold()\n\nreturn 2 arrays: ϕps and θps. \n\nWhen ϕps is the cumulation distribution of scattering angle and θps is the angle between new trajectory and the direction of the photon before scattering corresponding to each ϕps.\n\n\n\n\n\n","category":"method"},{"location":"Simulation/WithinWater/","page":"Light within Water","title":"Light within Water","text":"OceanLight.jl gives the options of constructing the irradiance solution field, depending on the initial condition and the problem one wish to solve. ","category":"page"},{"location":"Simulation/WithinWater/#Single-point-source","page":"Light within Water","title":"Single point source","text":"","category":"section"},{"location":"Simulation/WithinWater/","page":"Light within Water","title":"Light within Water","text":"If the problem is consisted of incoming photons on a single point (i.e. incoming photons only at the center of irradiance field,) the solution grid field is stored directly at ed solution field. ","category":"page"},{"location":"Simulation/WithinWater/","page":"Light within Water","title":"Light within Water","text":"transfer!(ed::Array{<:Float64,3},esol::Array{<:Float64,2},θ::Float64,ϕ::Float64,fres::Float64,ip::Int64,\n                   xpb::Float64,ypb::Float64,zpb::Float64,area::Vector{Float64},interi::Vector{Int64},\n                   interj::Vector{Int64},randrng,η::Array{<:Float64,2},ph::Array{<:Float64,1},\n                   θps::Array{<:Float64,1},p::Param,mode=0::Int64)","category":"page"},{"location":"Simulation/WithinWater/#OceanLight.transfer!","page":"Light within Water","title":"OceanLight.transfer!","text":"transfer!(ed::Array{<:Float64,3},esol::Array{<:Float64,2},θ::Float64,ϕ::Float64,fres::Float64,ip::Int64,\n               xpb::Float64,ypb::Float64,zpb::Float64,area::Vector{Float64},interi::Vector{Int64},\n               interj::Vector{Int64},randrng,η::Array{<:Float64,2},ph::Array{<:Float64,1},\n               θps::Array{<:Float64,1},p::Param,mode=0::Int64)\n\nDoing the Monte Carlo Simulation.\n\nArguments\n\ned::Array{<:Float64,3}: Irradiance solution grid \nesol::Array{<:Float64,2}: Irradiance solution grid for solar mode (under deverlopment)\nθ::Float64: angle of the light ray relative to the z axis: polar angle.\nϕ::Float64: angle of the light ray relative to the x axis: azimuthal angle.\nfres::Float64: fresnel coefficient or fractional transmission for unpolarized light\nip::Int64: current photon's number being simulated (ie. ip ∈ {1, 2,..., nphoton}) \nxpb::Float64: initial x coordination of the photon.\nypb::Float64: initial y coordination of the photon.\nzpb::Float64: initial z coordination of the photon.\narea::Vector{Float64}: 4 values of the area inside a single grid where a photon lands corresponding to: 4 corners of the square grid.\ninteri::Vector{Int64}: x coordination (grid number) of a single grid where a photon lands: from bottom left, bottom right, upper left, and upper right.\ninterj::Vector{Int64}: y coordination (grid number) of a single grid where a photon lands: from bottom left, bottom right, upper left, and upper right.\nrandrng: PRNGs (pseudorandom number generators) exported by the Random package.\nη::Array{<:Float64,2}: water surface elevation.\nph::Array{<:Float64,1}: cumulation distribution of scattering angle (obtained from phasePetzold())\nθps::Array{<:Float64,1}: angle between new trajectory and the direction of the photon before scattering corresponding to each ϕps (obtained from phasePetzold())\np::Param: simulation parameters.\nmode::Int64: mode of different irradinace calculation (under deverlopment)\n\n\n\n\n\n","category":"function"},{"location":"Simulation/WithinWater/#Multiple-points-source","page":"Light within Water","title":"Multiple points source","text":"","category":"section"},{"location":"Simulation/WithinWater/","page":"Light within Water","title":"Light within Water","text":"If the problem is consisted of incoming photons on a multiple point (i.e. incoming photons everywhere on irradiance field,) OceanLight.jl will track each photon individually and stored the irradiance contribution on ed1d with its coordination at edi, edj, and edk, and later, combine into a single solution. ","category":"page"},{"location":"Simulation/WithinWater/","page":"Light within Water","title":"Light within Water","text":"transfer!(ed1d::Array{<:Float64,1},edi::Array{<:Int64,1},edj::Array{<:Int64,1},\n                   edk::Array{<:Int64,1},count::Array{<:Int64,1},esol::Array{<:Float64,2},θ::Float64,ϕ::Float64,fres::Float64,\n                   ip::Int64,xpb::Float64,ypb::Float64,zpb::Float64,randrng,η::Array{<:Float64,2},\n                   ph::Array{<:Float64,1},θps::Array{<:Float64,1},p::Param,mode=0::Int64)","category":"page"},{"location":"Simulation/WithinWater/#OceanLight.transfer!-2","page":"Light within Water","title":"OceanLight.transfer!","text":"transfer!(ed1d::Array{<:Float64,1},edi::Array{<:Int64,1},edj::Array{<:Int64,1},\n               edk::Array{<:Int64,1},count::Array{<:Int64,1},esol::Array{<:Float64,2},θ::Float64,ϕ::Float64,fres::Float64,\n               ip::Int64,xpb::Float64,ypb::Float64,zpb::Float64,randrng,η::Array{<:Float64,2},\n               ph::Array{<:Float64,1},θps::Array{<:Float64,1},p::Param,mode=0::Int64)\n\nDoing the Monte Carlo Simulation.\n\nArguments\n\ned1d::Array{<:Float64,1}: fraction of irradiance that will be assigned to 4 corners of a grid where a photon lands\nedi::Array{<:Int64,1}: x coordination (grid number) of a single grid where a photon lands: from bottom left, bottom right, upper left, and upper right.\nedj::Array{<:Int64,1}: y coordination (grid number) of a single grid where a photon lands: from bottom left, bottom right, upper left, and upper right.\nedk::Array{<:Int64,1}: number of the energy layer that the photons travel, from the top ztop in 1 by 4 array\ncount::Array{<:Int64,1}: (parrallel computing) dummy integer span from 1 to 4 to keep track of the size of the ed1d, edi, edj, edk. \nesol::Array{<:Float64,2}:  Irradiance solution grid for solar mode (under deverlopment)\nθ::Float64: angle of the light ray relative to the z axis: polar angle.\nϕ::Float64: angle of the light ray relative to the x axis: azimuthal angle.\nfres::Float64: fresnel coefficient or fractional transmission for unpolarized light.\nip::Int64: current photon's number being simulated (ie. ip ∈ {1, 2,..., nphoton}) \nxpb::Float64: initial x coordination of the photon.\nypb::Float64: initial y coordination of the photon.\nzpb::Float64: initial z coordination of the photon.\nrandrng: PRNGs (pseudorandom number generators) exported by the Random package\nη::Array{<:Float64,2}: water surface elevation.\nph::Array{<:Float64,1}: cumulation distribution of scattering angle (obtained from phasePetzold())\nθps::Array{<:Float64,1}: angle between new trajectory and the direction of the photon before scattering corresponding to each ϕps (obtained from phasePetzold())\np::Param: simulation parameters.\nmode::Int64: mode of different irradinace calculation (under deverlopment)\n\n\n\n\n\n","category":"function"},{"location":"QuickStart/Center/#Quick-Start","page":"Photons at the center","title":"Quick Start","text":"","category":"section"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"In this example, we introduce the OceanLight calculation of downwelling irradiance field underneath the flat surfcae. The code example here can be directly pasted onto Julia terminal, run through .jl script file, or IJulia notebook. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"First, we import OceanLight packages and another random dependent package, that will be used as a seed to generate random number in the Monte Carlo simulation.","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"cd(mktempdir()) \nusing Pkg \nPkg.add(\"OceanLight\") \nPkg.add(\"Plots\") ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"using OceanLight \nusing Random","category":"page"},{"location":"QuickStart/Center/#Problem","page":"Photons at the center","title":"Problem","text":"","category":"section"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"In this example, the problem is to calculate the downwelling irradiance field, when the surface is completely flat, and a total of 100,000 photons is focused at a single point in the center. Our domain of interest is defined as ( x, y \\in [-10\\,\\mathrm{m}, 10\\,\\mathrm{m}] ), and z in mathrm-190mmathrm10m in depth, corresponding to a grid resolution of 512 times 512 times 200  points. Periodic boundary conditions are applied at the domain boundaries. The attenuation properties of water are characterized by an absorption coefficient of a = 00196 and scattering coefficient b = 00031, which corresponding to the optical properties of sea water at wavelength 490 mathrmnm [1]. ","category":"page"},{"location":"QuickStart/Center/#Initial-Condition","page":"Photons at the center","title":"Initial Condition","text":"","category":"section"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"OceanLight accesses all input variables in .yml format and stores their values in Param structure.","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"All input variables required by OceanLight can be separated into 3 categories:","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"Irradiance: Setting up the dimension of downwelling irradiance field calculation grid. \nPhoton: Number of Photons and optical properties of the water.\nWave: Structure of surface wave field. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"# irradiance\nnz = 200                    # Number of total grid point in z direction\ndz = 1                      # Physical length of grid spacing in z direction\nnxe = 512                   # Number of grid point of the calculation grid in x direction  \nnye = 512                   # Number of grid point of the calculation grid in y direction  \nnum = 31                    # Constant value (number of angle measurement in Kirk,1981)\nztop = 10                   # Number of grid point in air phase in z direction\n# photon\nnphoton = 100000            # Number of photons being generated at each grid point \nkr = 10                     # Dummy variable (in developement, not being used)                    \nnxp = 512                   # Number of grid points in x direction where photon can be emitted\nkbc = 0                     # Binary value 0 and 1 depending on Boundary condition being implemented \nb = 0.0031                  # Scattering coefficient \nnyp = 512                   # Number of grid points in x direction where photon can be emitted\na = 0.0196                  # Absorbtance coefficient\n# wave\npey = 2*pi/20.0             # Lowest wavenumber that can be captured during the derivative of surface elevation in x direction\nnxeta = 512                 # Number of surface elevation grid point in x direction\nnyeta = 512                 # Number of surface elevation grid point in y direction\npex = 2*pi/20.0              # Lowest wavenumber that can be captured during the derivative of surface elevation in y direction","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"NOTE: num must be set to a constant value of 31 (number of angle measurement in Kirk, 1981 [2]). kbc accepts only binary values (0 or 1), representing periodic boundary conditions. In contrast to grid spacing dz in z-direction, , the grid spacings in the x- and y-directions (dx and dy) are calculated automatically by OceanLight.readparams,  using the formulas dx times nxe  = frac2pipex, and dy times nye = frac2pipey. For more detail on all parameters  used, see Simulation parameters. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"To create a input variable file suitable for this package, user can either create a new file in .yml format, copy, and paste the code block above, or using a build-in function OceanLight.writeparams to automate the process. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"The function OceanLight.writeparams converts the dictionary of input variables into the light.yml file. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"data=Dict(\"irradiance\"=>Dict(\"nxe\"=>nxe,\"nye\"=>nye,\"nz\"=>nz,\"dz\"=>dz,\"ztop\"=>ztop,\"num\"=>num),\n            \"wave\"=>Dict(\"pex\"=>pex,\"pey\"=>pey,\"nxeta\"=>nxeta,\"nyeta\"=>nyeta),\n            \"photon\"=>Dict(\"nxp\"=>nxp,\"nyp\"=>nyp,\"nphoton\"=>nphoton,\"a\"=>a,\"b\"=>b,\"kr\"=>kr,\"kbc\"=>kbc))\n\nOceanLight.writeparams(data)","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"Once the input variable file is generated, this package calculates other related variables and stores all values in the Param structure, through OceanLight.readparams. The default input variable file name that will be read is light.yml, but can be specified by users. In this case, we store Param structure in variable p. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"p = OceanLight.readparams()","category":"page"},{"location":"QuickStart/Center/#Initialize-Parameters","page":"Photons at the center","title":"Initialize Parameters","text":"","category":"section"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"Before the simulation, user needs to declare and initialize all parameters and their dimensions. ","category":"page"},{"location":"QuickStart/Center/#Air-Water-Interaction","page":"Photons at the center","title":"Air-Water Interaction","text":"","category":"section"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"During the light refraction between two mediums calculation, OceanLight requires the surface elevation attribution: eta; surface elevation, eta_x; partial derivative of eta in x direction, and eta_y; partial derivative of eta in y direction. All surface elevation distribution, as specified above, need to have the same dimension with the incoming photons' grid. Hence, ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"η = zeros(p.nxs,p.nys)\nηx = zeros(p.nxs,p.nys)\nηy = zeros(p.nxs,p.nys)","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"After photons' interaction with the surface, OceanLight requires the information of specific coordinate of photon in cartesian grid xpbypbzpb, the direction in which photon will travel in polar coordinate θϕ, and the fraction of light that transmit through the water fres: all in the dimension of incoming photon grid size. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"xpb = zeros(p.nxp,p.nyp);\nypb = zeros(p.nxp,p.nyp);\nzpb = zeros(p.nxp,p.nyp);\nθ = zeros(p.nxp,p.nyp);\nϕ = zeros(p.nxp,p.nyp);\nfres = zeros(p.nxp,p.nyp);","category":"page"},{"location":"QuickStart/Center/#Monte-Carlo-simulation","page":"Photons at the center","title":"Monte Carlo simulation","text":"","category":"section"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"OceanLight tracks the path of each photon travelling inside the water medium and store the irradiance value in the grid ed. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"Users need to specify these variables and corresponding dimension. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"ed = zeros(p.nx, p.ny, p.nz)\nesol = zeros(p.num, p.nz)\nrandrng = MersenneTwister(1234)\narea = zeros(4)\ninteri = zeros(Int64,4)\ninterj = zeros(Int64,4)\nix = div(p.nxη,2)+1\niy = div(p.nyη,2)+1\nϕps,θps = OceanLight.phasePetzold()","category":"page"},{"location":"QuickStart/Center/#Air-Water-Interaction-2","page":"Photons at the center","title":"Air-Water Interaction","text":"","category":"section"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"During the air-water interaction process, OceanLight simulates the photons transfer directly downward from the air side, interacts with the water surface, and transfer down into water medium. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"User can generate random surface elevation attribution etaeta_xeta_y with OceanLight.setwave!, or provided specific data eta_0eta_x0eta_y0  . OceanLight can map the user's provided data of eta_0eta_x0eta_y0, which might have different dimension onto the suitable dimension of input value ηηxηy with OceanLight.convertwave!.","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"In this example, we will consider the case of flat surface elevation. Hence, ηηxηy is equal to the matrix of zeros. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"Once all the input variables are in place, OceanLight.interface! calculate the refraction of the light between two medium given surface elevation attribution and return the position, reflectance angle, and transmission ratio. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"OceanLight.interface!(xpb,ypb,zpb,θ,ϕ,fres,η,ηx,ηy,p)","category":"page"},{"location":"QuickStart/Center/#Monte-Carlo-simulation-2","page":"Photons at the center","title":"Monte Carlo simulation","text":"","category":"section"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"OceanLight simulates the photon traveling inside the water medium, given its initial position xpbypbzpb and the direction it started withθϕ. Once photons are inside the water, OceanLight will track its path, governed by its probability distribution and the attenuated coefficient input, and store the irradiance value in the grid ed. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"The transfer! function simulate a single photon path and store its landed position on the grid ed. Hence, to simulate multiple photons, users need to loop the transfer! function and giving the input of an individual photon's number ip. Thus, OceanLight could facilitate parallel computation. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"for ip = 1:p.nphoton\n    OceanLight.transfer!(ed,esol,θ[ix,iy],ϕ[ix,iy],fres[ix,iy],ip,xpb[ix,iy],\n        ypb[ix,iy],zpb[ix,iy],area,interi,interj,randrng,η,ϕps,θps,p,1)\nend","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"Lastly, once the field ed is obtained. The applybc! apply and ensure the boundary condition of the ed. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"OceanLight.applybc!(ed,p)","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"Once the simulation is over, the downwelling irradiance field I(xyz) is stored in variable ed. To export the data, the build-in function OceanLight.exported export data and its statistical information in to .h5 format, depended on the path given by user. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"The result downwelling irradiance field I(xyz) is in 3 dimension tensor, where the first two dimensions represent horizontal field, and the last represents the vertical field or depth. The first few depth layer represents the air phase, hence I(xyz) is zeros, depending on how many layer specified as air phases ztop. To visualize using Plots julia package, users can try the example code below. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"using Plots \nusing Plots.Measures\n\nl = @layout [grid(2,1) a{0.5w} ; b{0.5w}]\n\np1 = heatmap(p.x .-10,p.y .-10,log.(ed[:,:,40]),clim=(-20,0),framestyle = :box,grid = false, c =cgrad(:viridis)\n    ,legend = :none,xlabel=\"\\$x(m)\\$\",ylabel=\"\\$y(m)\\$\")\np2 = heatmap(p.x .-10,p.y .-10,log.(ed[:,:,160]),clim=(-20,0),framestyle = :box,grid = false, c =cgrad(:viridis)\n    ,legend = :none,xlabel=\"\\$x(m)\\$\",ylabel=\"\\$y(m)\\$\")\np3 = heatmap(p.x .-10,reverse(p.z) ,reverse(transpose(log.(ed[:,256,:]))),clim=(-20,0),framestyle = :box,grid = false, c =cgrad(:viridis)\n    ,xlabel=\"\\$x(m)\\$\",ylabel=\"\\$z(m)\\$\"\n    ;cbar_title=\"\\$\\\\ln(I(x,y,z))\\$\")\nplot(p1, p2,p3, layout = l,\ntitle = [\"($i)\" for j in 1:1, i in [\"a\",\"b\",\"c\"]], titleloc = :left, titlefont = font(8)\n,left_margin = [10mm 0mm],right_margin = [10mm 0mm])\nplot!(size=(900,1200))","category":"page"},{"location":"QuickStart/Center/#Reference","page":"Photons at the center","title":"Reference","text":"","category":"section"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"[1]: Smith, R. C., & Baker, K. S. (1981). Optical properties of the clearest natural waters (200-800 nm). Applied optics, 20(2), 177–184. https://doi.org/10.1364/AO.20.000177 ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"[2]: Kirk, J. T. O. (1981). Monte Carlo procedure for simulating the penetration of light into natural waters. In Technical paper - Commonwealth Scientific and Industrial Research Organization (Vol. 36).","category":"page"},{"location":"module/Parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"module/Parameters/#Coordinate-system-and-notation","page":"Parameters","title":"Coordinate system and notation","text":"","category":"section"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"OceanLight.jl is formulated in the spherical system hatzeta = (thetaphi), where polar angle theta is measured from the direction of hatz and the azimuthal ange phi is measured positive counter clockwise from hatx, when looking toward the origin along hatz. Let hatxi denoted a unit vector pointing in the desired direction, when hatxi=left(xi_xxi_yxi_zright), and becasue hatxi is of unit length, its component satisfy hatxi_x^2+hatxi_y^2+hatxi_z^2=1. [1] Therefore, ","category":"page"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"hatxi = beginbmatrix sin(theta)cos(phi) sin(theta)sin(phi) cos(theta) endbmatrix","category":"page"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"To simplify the term above, we simplify hatxi by using the cosine parameter.","category":"page"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"hatxi = beginbmatrixmu_x mu_y mu_z endbmatrix = beginbmatrixsin(theta)cos(phi) sin(theta)sin(phi) cos(theta) endbmatrix ","category":"page"},{"location":"module/Parameters/#Local-coordinate-system","page":"Parameters","title":"Local coordinate system","text":"","category":"section"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"When we calculate for the scattering direction, our result is in the local coordination system (hat(theta)hat(phi)hat(r)), when radial unit vector hat(r) is the same initial direction of photons before scattering hatxi, the azimuthal unit vector hat(phi) is defined by the cross product of the ocean coordinate system hatz and the incident vector's direction hatphi=frachatztimeshatrhatztimeshatr, and polar unit vector is given by hattheta=hatphitimeshatr.  Therefore, the unit vector of the scattered direction of photons hatxi_s can be described in the local coordination system (hat(theta)hat(phi)hat(r)) as,","category":"page"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"hatxi_(s) = beginbmatrix sin(theta_s)cos(phi_s) sin(theta_s)sin(phi_s) cos(theta_s) endbmatrix","category":"page"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"when, theta_s and phi_s is polar angle and azimuthal angle in relative to the local coordinate system (hat(theta)hat(phi)hat(r)). ","category":"page"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"To change from the local coordinate system to the cartesian coordination in the global system, we multiply hatxi_(s) by the basis of our local coordinate system.","category":"page"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"beginbmatrix mu_x mu_y mu_z endbmatrix = beginbmatrixhattheta  hatphi  hatr endbmatrixbeginbmatrixhatxi_(s)endbmatrix","category":"page"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"And, after we do the cross product and substitute hatxi_(s). ","category":"page"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"beginbmatrix mu_x mu_y mu_z endbmatrix = beginbmatrixfracmu_xmu_zsqrt1-mu_z^2-fracmu_ysqrt1-mu_z^2mu_xfracmu_ymu_zsqrt1-mu_z^2fracmu_xsqrt1-mu_z^2mu_y-sqrt1-mu_z^20mu_z endbmatrixbeginbmatrix sin(theta_s)cos(phi_s) sin(theta_s)sin(phi_s) cos(theta_s) endbmatrix","category":"page"},{"location":"module/Parameters/#Reference","page":"Parameters","title":"Reference","text":"","category":"section"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"[1]: Mobley, C. (2021). Light and Radiometry. In A Ocean Optics Web Book. https://www.oceanopticsbook.info","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Kirk, J. T. O. (1981). Monte Carlo procedure for simulating the penetration of light into natural waters. In Technical paper - Commonwealth Scientific and Industrial Research Organization (Vol. 36).","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Petzold, T. J. (1972). Volume Scattering Functions for Selected Ocean Waters. UC San Diego: Scripps Institution of Oceanography. Retrieved from https://escholarship.org/uc/item/73p3r43q","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Mobley, C. (2021). Light and Radiometry. In A Ocean Optics Web Book. https://www.oceanopticsbook.info","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Mobley, C. (1994). Monte Carlo Methods. Light and Water: Radiative Transfer in Natural Waters (pp. 321-326). Academic Press. ","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Mobley, C. (1994). Across the Surface. Light and Water: Radiative Transfer in Natural Waters (pp. 155-157). Academic Press. ","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Hecht, E. (2001). The Propagation of Light. Optics (pp. 113-115). Addison-Wesley. ","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Sears, F.W. (1949). Polarization Optics (pp. 173-174). Addison-Wesley","category":"page"},{"location":"module/MonteCarlo/#Fundamental-Principle-of-Monte-Carlo-simulation","page":"Monte Carlo Simulation","title":"Fundamental Principle of Monte Carlo simulation","text":"","category":"section"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"The basis of Monte Carlo method lies in the idea that, if we know the probability of occurence of each separate event in a sequence of events, then we can determine the probability that the entire sequence of events will occur [1]. In the simulation of light within the water, each photon, after being transmitted into the water, travels in the medium, interacts with the molecule: absorb and scatter, and either being fully absorbed or reaches the measurement devices. With the multiple photons, we can determine the distribution of the light field. ","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"<img  src=\"https://raw.githubusercontent.com/haoboatlab/OceanLight.jl/main/docs/src/assets/IllustrationOfMonteCarloMethod.png\" width=\"600\" align=\"center\">","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"Illustration of three photons that are being emitted and travel inside the water medium[1]","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"As mentioned above, the separate event that happens for each photon is consisted of travelling some distance in the medium, aborbing, and scattering. All of the events are determined by some probability. Hence, we define the probability distribution of a random number p_Re[1]","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"p_Re (Re) equiv begincases\n1  quad 0 leq Re leq 1 \n0  quad Re  0 cup Re  1\nendcases","category":"page"},{"location":"module/MonteCarlo/#The-optical-path-length","page":"Monte Carlo Simulation","title":"The optical path length","text":"","category":"section"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"After the photon's interaction with the medium or being transmitted into the water, we calculate for the distance the photon would travel before interact with the medium agian. The distance r is defined by the equation below, when c is the beam attenuated coefficient or the addition of absorbtance coefficient a and scatterance coefficient b. [1]","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"r=-frac1clnRe","category":"page"},{"location":"module/MonteCarlo/#Sampling-photon-interaction-type","page":"Monte Carlo Simulation","title":"Sampling photon interaction type","text":"","category":"section"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"Once, the photon travels for distance r, we, then, determine how it interacts with the medium: whether a photon will be absorbed or scattered. This can be done by drawing a random number Re and compare with the albedo of single scattering omega_0 = fracbc, if  Releqomega_0, the photon is being absorbed, and if Regeqomega_0, the photon is being scattered. [1]","category":"page"},{"location":"module/MonteCarlo/#Sampling-scattering-direction","page":"Monte Carlo Simulation","title":"Sampling scattering direction","text":"","category":"section"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"In the scattering event, we will calculate the scattering direction of the photon in the local spherical coordinate with azimuthal angle varphi and polar angle theta. Azimuthal angle varphi is uniformly distribute between 0 and 2pi hence, [1]","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"varphi = 2piRe","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"The angle between new trajectory and the direction before scattering theta is defined by the cumulative distribution, based on the experiment conducted by the Petzold(1972). [2]","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"<img  src=\"https://raw.githubusercontent.com/haoboatlab/OceanLight.jl/main/docs/src/assets/CDFscatteringangle.png\" width=\"600\" align=\"center\">","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"Cumulative Distribution Function of the polar angle or the angle between new trajectory and the direction before scattering theta based on the data from Kirk(1981)[3]","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"Hence, we draw a random number Re and find the corresponding polar angle theta from the cumulative distribution function.","category":"page"},{"location":"module/MonteCarlo/#Reference","page":"Monte Carlo Simulation","title":"Reference","text":"","category":"section"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"[1]: Mobley, C. (1994). Monte Carlo Methods. Light and Water: Radiative Transfer in Natural Waters (pp. 321-326). Academic Press.  ","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"[2]: Petzold, T. J. (1972). Volume Scattering Functions for Selected Ocean Waters. UC San Diego: Scripps Institution of Oceanography. Retrieved from https://escholarship.org/uc/item/73p3r43q","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"[3]: Kirk, J. T. O. (1981). Monte Carlo procedure for simulating the penetration of light into natural waters. In Technical paper - Commonwealth Scientific and Industrial Research Organization (Vol. 36).","category":"page"},{"location":"#OceanLight.jl-Documentation","page":"Home","title":"OceanLight.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OceanLight.jl calculates the downwelling irradiance field in the upper ocean. By implementing the Monte Carlo method, this simulation achieves the path of Photons: starting from the refraction in the air-water interface, to some specific depth underneath the water body. ","category":"page"},{"location":"#Quick-Install","page":"Home","title":"Quick Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install Julia\nLaunch Julia and type","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"OceanLight\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"After installing, verify that OceanLight works as intended by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.test(\"OceanLight\")","category":"page"},{"location":"#Result","page":"Home","title":"Result","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Center1e8)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simulation of 10^8 Photons at the center of the flat surface. (a) irradiance field on the horizontal plane at 30 mathrmm depth. (b) irradiance field on the horizontal plane at 150 mathrmm depth. (c) irradiance field on the vertical plane at the center.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img  src=\"https://raw.githubusercontent.com/haoboatlab/OceanLight.jl/main/docs/src/assets/Center1e8.png\" width=\"600\" align=\"center\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simulation of 1000 Photons at the every grid point with observed surface elevation. (a) irradiance field on the horizontal plane at 30 mathrmm depth. (b) irradiance field on the horizontal plane at 150 mathrmm depth. (c) irradiance field on the vertical plane at the center.","category":"page"},{"location":"Simulation/Exporting/#Exporting-data","page":"Exporting data","title":"Exporting data","text":"","category":"section"},{"location":"Simulation/Exporting/","page":"Exporting data","title":"Exporting data","text":"Once the OceanLight.jl simulation completes, our solution grid field can be accessed from variable ed. ","category":"page"},{"location":"Simulation/Exporting/#Periodic-boundary-condition","page":"Exporting data","title":"Periodic boundary condition","text":"","category":"section"},{"location":"Simulation/Exporting/","page":"Exporting data","title":"Exporting data","text":"Before accessing the data, OceanLight.jl offers a function in which applying Periodic Boundary Condition on the solution fied ed.","category":"page"},{"location":"Simulation/Exporting/","page":"Exporting data","title":"Exporting data","text":"applybc!(ed::Array{<:Float64,3},p::Param)","category":"page"},{"location":"Simulation/Exporting/#OceanLight.applybc!-Tuple{Array{<:Float64, 3}, Param}","page":"Exporting data","title":"OceanLight.applybc!","text":"applybc!(ed::Array{<:Float64,3},p::Param)\n\nApplying the periodic boundary condition on our irradiance output grid ed if kbc sets to 1 \n\n\n\n\n\n","category":"method"},{"location":"Simulation/Exporting/#Exporting-data-to-HDF-file","page":"Exporting data","title":"Exporting data to HDF file","text":"","category":"section"},{"location":"Simulation/Exporting/","page":"Exporting data","title":"Exporting data","text":"Our data can be exported to .h5 file, with 3 modes: 2D, 3D, and full.  In 2D mode, .h5 file will store the statistic of our irradiance field solution; storing mean μ, variance σ, and cv cv, and the 2 dimenstion cross-section of our solution: xz, yz, and xy. ","category":"page"},{"location":"Simulation/Exporting/","page":"Exporting data","title":"Exporting data","text":"If specified 3D mode, in addition to the data from 2D mode, OceanLight.jl will stored the ed solution. ","category":"page"},{"location":"Simulation/Exporting/","page":"Exporting data","title":"Exporting data","text":"If specified full mode, in addition to the data from 3D mode, OceanLight.jl will stored the physical coordination of the ed solution. ","category":"page"},{"location":"Simulation/Exporting/","page":"Exporting data","title":"Exporting data","text":"exported(ed::Array{<:Real,3},η::Array{<:Real,2},p::Param,\n                  fname::String,mode=\"2D\"::String,nk=0::Int64)","category":"page"},{"location":"Simulation/Exporting/#OceanLight.exported","page":"Exporting data","title":"OceanLight.exported","text":"exported(ed::Array{<:Real,3},η::Array{<:Real,2},p::Param,\n              fname::String,mode=\"2D\"::String,nk=0::Int64)\n\nexported the irradiance data into fname.h5 file. \n\nThere are 3 modes of exporting the data: 2D, 3D, and full. If not specified the mode will automatically set to 2D. \n\n\n\n\n\n","category":"function"}]
}
