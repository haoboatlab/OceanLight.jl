var documenterSearchIndex = {"docs":
[{"location":"QuickStart/Center/#Quick-Start","page":"Photons at the center","title":"Quick Start","text":"","category":"section"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"In this example, we introduce the OceanLight calculation of downwelling irradiance field underneath the flat surface. The code example here can be directly pasted onto Julia terminal, run through .jl script file, or IJulia notebook. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"First, we import OceanLight packages and another random dependent package, that will be used as a seed to generate random number in the Monte Carlo simulation.","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"cd(mktempdir()) \nusing Pkg \nPkg.add(\"OceanLight\") \nPkg.add(\"Plots\") ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"using OceanLight \nusing Random","category":"page"},{"location":"QuickStart/Center/#Problem","page":"Photons at the center","title":"Problem","text":"","category":"section"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"In this example, the problem is to calculate the downwelling irradiance field, when the surface is completely flat, and a total of 10,000,000 photons is focused at a single point in the center. Our domain of interest is defined as xy in leftmathrm-10mmathrm10mright, and z in leftmathrm-190mmathrm10mright in depth, corresponding to a grid resolution of 512 times 512 times 200  points. Periodic boundary conditions are applied at the domain boundaries. The attenuation properties of water are characterized by an absorption coefficient of a = 00196 and scattering coefficient b = 00031, which corresponding to the optical properties of sea water at wavelength 490 mathrmnm [1]. ","category":"page"},{"location":"QuickStart/Center/#Initial-Condition","page":"Photons at the center","title":"Initial Condition","text":"","category":"section"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"OceanLight accesses all input variables in .yml format and stores their values in Param structure.","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"All input variables required by OceanLight can be separated into 3 categories:","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"Irradiance: Setting up the dimension of downwelling irradiance field calculation grid. \nPhoton: Number of Photons and optical properties of the water.\nWave: Structure of surface wave field. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"# irradiance\nnz = 200                    # Number of total grid point in z direction\ndz = 1                      # Physical length of grid spacing in z direction\nnxe = 512                   # Number of grid point of the calculation grid in x direction  \nnye = 512                   # Number of grid point of the calculation grid in y direction  \nnum = 31                    # Constant value (number of angle measurement in Kirk,1981)\nztop = 10                   # Number of grid point in air phase in z direction\n# photon\nnphoton = 10000000          # Number of photons being generated at each grid point \nkr = 10                     # Dummy variable (in developement, not being used)                    \nnxp = 512                   # Number of grid points in x direction where photon can be emitted\nkbc = 0                     # Binary value 0 and 1 depending on Boundary condition being implemented \nb = 0.0031                  # Scattering coefficient \nnyp = 512                   # Number of grid points in x direction where photon can be emitted\na = 0.0196                  # Absorbtance coefficient\n# wave\npey = 2*pi/20.0             # Lowest wavenumber that can be captured during the derivative of surface elevation in x direction\nnxeta = 512                 # Number of surface elevation grid point in x direction\nnyeta = 512                 # Number of surface elevation grid point in y direction\npex = 2*pi/20.0             # Lowest wavenumber that can be captured during the derivative of surface elevation in y direction","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"NOTE: num must be set to a constant value of 31 (number of angle measurement in Kirk, 1981 [2]). kbc accepts only binary values (0 or 1), representing periodic boundary conditions. In contrast to grid spacing dz in z-direction, the grid spacings in the x- and y-directions (dx and dy) are calculated automatically by OceanLight.readparams,  using the formulas dx times nxe  = frac2pipex, and dy times nye = frac2pipey. For more detail on all parameters  used, see Simulation parameters. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"To create a input variable file suitable for this package, user can either create a new file in .yml format, copy, and paste the code block above, or using a build-in function OceanLight.writeparams to automate the process. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"The function OceanLight.writeparams converts the dictionary of input variables into the light.yml file. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"data=Dict(\"irradiance\"=>Dict(\"nxe\"=>nxe,\"nye\"=>nye,\"nz\"=>nz,\"dz\"=>dz,\"ztop\"=>ztop,\"num\"=>num),\n            \"wave\"=>Dict(\"pex\"=>pex,\"pey\"=>pey,\"nxeta\"=>nxeta,\"nyeta\"=>nyeta),\n            \"photon\"=>Dict(\"nxp\"=>nxp,\"nyp\"=>nyp,\"nphoton\"=>nphoton,\"a\"=>a,\"b\"=>b,\"kr\"=>kr,\"kbc\"=>kbc))\n\nOceanLight.writeparams(data)","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"Once the input variable file is generated, this package calculates other related variables and stores all values in the Param structure, through OceanLight.readparams. The default input variable file name that will be read is light.yml, but can be specified by users. In this case, we store Param structure in variable p. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"p = OceanLight.readparams()","category":"page"},{"location":"QuickStart/Center/#Initialize-Parameters","page":"Photons at the center","title":"Initialize Parameters","text":"","category":"section"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"Before the simulation, user needs to declare and initialize all parameters and their dimensions. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"During the light refraction between two mediums (air and water) calculation, OceanLight requires the surface elevation attribution: eta; surface elevation, eta_x; partial derivative of eta in x direction, and eta_y; partial derivative of eta in y direction. All surface elevation distribution, as specified above, need to have the same dimension with the incoming photons' grid. Hence, ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"η = zeros(p.nxs,p.nys)\nηx = zeros(p.nxs,p.nys)\nηy = zeros(p.nxs,p.nys)","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"After photons' interaction with the surface, OceanLight requires the information of specific coordinate of photon in cartesian grid xpbypbzpb, the direction in which photon will travel in polar coordinate θϕ, and the fraction of light that transmit through the water fres: all in the dimension of incoming photon grid size. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"xpb = zeros(p.nxp,p.nyp);\nypb = zeros(p.nxp,p.nyp);\nzpb = zeros(p.nxp,p.nyp);\nθ = zeros(p.nxp,p.nyp);\nϕ = zeros(p.nxp,p.nyp);\nfres = zeros(p.nxp,p.nyp);","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"During the air-water interaction process, OceanLight simulates the photons transfer directly downward from the air side, interacts with the water surface, and transfer down into water medium. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"User can generate random surface elevation attribution etaeta_xeta_y with OceanLight.setwave!, or provided specific data eta_0eta_x0eta_y0  . OceanLight can map the user's provided data of eta_0eta_x0eta_y0, which might have different dimension onto the suitable dimension of input value ηηxηy with OceanLight.convertwave!.","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"In this example, we will consider the case of flat surface elevation. Hence, ηηxηy is equal to the matrix of zeros. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"Once all the input variables are in place, OceanLight.interface! calculate the refraction of the light between two medium given surface elevation attribution and return the position, reflectance angle, and transmission ratio. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"OceanLight.interface!(xpb,ypb,zpb,θ,ϕ,fres,η,ηx,ηy,p)","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"OceanLight tracks the path of each photon travelling inside the water medium and store the irradiance value in the grid ed. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"Users need to specify these variables and corresponding dimension. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"ed = zeros(p.nx, p.ny, p.nz)\nesol = zeros(p.num, p.nz)\nrandrng = MersenneTwister(1234)\narea = zeros(4)\ninteri = zeros(Int64,4)\ninterj = zeros(Int64,4)\nix = div(p.nxη,2)+1\niy = div(p.nyη,2)+1\nϕps,θps = OceanLight.phasePetzold()","category":"page"},{"location":"QuickStart/Center/#Monte-Carlo-Simulation","page":"Photons at the center","title":"Monte Carlo Simulation","text":"","category":"section"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"OceanLight simulates the photon traveling inside the water medium, given its initial position xpbypbzpb and the direction it started withθϕ. Once photons are inside the water, OceanLight will track its path, governed by its probability distribution and the attenuated coefficient input, and store the irradiance value in the grid ed. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"The transfer! function simulate a single photon path and store its landed position on the grid ed. Hence, to simulate multiple photons, users need to loop the transfer! function and giving the input of an individual photon's number ip. Thus, OceanLight could facilitate parallel computation. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"for ip = 1:p.nphoton\n    OceanLight.transfer!(ed,esol,θ[ix,iy],ϕ[ix,iy],fres[ix,iy],ip,xpb[ix,iy],\n        ypb[ix,iy],zpb[ix,iy],area,interi,interj,randrng,η,ϕps,θps,p,1)\nend","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"Lastly, once the field ed is obtained. The applybc! apply and ensure the boundary condition of the ed. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"OceanLight.applybc!(ed,p)","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"Once the simulation is over, the downwelling irradiance field I(xyz) is stored in variable ed. To export the data, the build-in function OceanLight.exported export data and its statistical information in to .h5 format, depended on the path given by user. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"The result downwelling irradiance field I(xyz) is in 3 dimension tensor, where the first two dimensions represent horizontal field, and the last represents the vertical field or depth. The first few depth layer represents the air phase, hence I(xyz) is zeros, depending on how many layer specified as air phases ztop. To visualize using Plots julia package, users can try the example code below. ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"First, the irradiance field I(xyz) is normalized by its maximum value I_0. To prevent undefined values NaN during logarithmic scaling, all zero-valued grid points are replaced with its minimum value.","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"max_val, max_loc = findmax(ed)\ned = ed./max_val\nnonzero_vals = ed[ed .!= 0]\nmin_val = minimum(nonzero_vals)\n\nfor i in 1:Int(nxe+1)\n    for j in 1:Int(nye+1)\n        for k in ztop:nz\n            if ed[i,j,k] == 0\n                ed[i,j,k] = min_val\n            end\n        end\n    end\nend","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"using Plots\nusing Plots.Measures\n\n# Choose slice indices\niy_c = 256   # y-index for vertical cross-section\niz_a = 40    # z-index for panel (a)\niz_b = 160   # z-index for panel (b)\n\n# Define layout: 2 rows, 2 columns, but right column spans both rows\nl = @layout [grid(2,1) c]\n\n# Panel (a) : z = iz_a\np1 = heatmap(\n    p.x .-10, p.y .-10, log.(ed[:,:,iz_a]),\n    clim=(-20,-7), framestyle=:box, grid=false,\n    c=cgrad(:viridis), legend=:none,\n    xlabel=\"\\$x(m)\\$\", ylabel=\"\\$y(m)\\$\",\n    title=\"(a) z = $(round(p.z[iz_a], digits=1)) m\",\n    xlim=[minimum(p.x).-10, maximum(p.x).-10],\n    ylim=[minimum(p.y).-10, maximum(p.y).-10])\nplot!(p1, [minimum(p.x).-10, maximum(p.x).-10], [p.y[iy_c]-10, p.y[iy_c]-10],\n      color=:red, lw=2, ls=:dash, alpha=0.6)\n\n# Panel (b) : z = iz_b\np2 = heatmap(\n    p.x .-10, p.y .-10, log.(ed[:,:,iz_b]),\n    clim=(-20,-7), framestyle=:box, grid=false,\n    c=cgrad(:viridis), legend=:none,\n    xlabel=\"\\$x(m)\\$\", ylabel=\"\\$y(m)\\$\",\n    title=\"(b) z = $(round(p.z[iz_b], digits=1)) m\",\n    xlim=[minimum(p.x).-10, maximum(p.x).-10],\n    ylim=[minimum(p.y).-10, maximum(p.y).-10])\nplot!(p2, [minimum(p.x).-10, maximum(p.x).-10], [p.y[iy_c]-10, p.y[iy_c]-10],\n      color=:red, lw=2, ls=:dash, alpha=0.6)\n\n# Panel (c) : vertical cross-section at y = iy_c\np3 = heatmap(\n    p.x .-10, reverse(p.z), reverse(transpose(log.(ed[:,iy_c,:]))),\n    clim=(-20,-7), framestyle=:box, grid=false,\n    c=cgrad(:viridis), ylim=(-(nz*dz-10),0),\n    xlabel=\"\\$x(m)\\$\", ylabel=\"\\$z(m)\\$\",\n    cbar_title=\"\\$\\\\ln\\\\frac{I(x,y,z)}{I_{0}}\\$\",\n    title=\"(c) y = $(round(p.y[iy_c]-10, digits=1)) m\",\n    xlim=[minimum(p.x).-10, maximum(p.x).-10])\n\n# Add horizontal lines for z = iz_a, iz_b\nplot!(p3, [minimum(p.x).-10, maximum(p.x).-10], [p.z[iz_a], p.z[iz_a]],\n      color=:red, lw=1.5, ls=:dash, label=\"\", alpha=0.6)\nplot!(p3, [minimum(p.x).-10, maximum(p.x).-10], [p.z[iz_b], p.z[iz_b]],\n      color=:red, lw=1.5, ls=:dash, label=\"\", alpha=0.6)\n\n# Combine\nplot(p1, p2, p3, layout=l,\n     size=(900,700),\n     titleloc=:left, titlefont=font(8),\n     left_margin=10mm, right_margin=10mm)\n","category":"page"},{"location":"QuickStart/Center/#Reference","page":"Photons at the center","title":"Reference","text":"","category":"section"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"[1]: Smith, R. C., & Baker, K. S. (1981). Optical properties of the clearest natural waters (200-800 nm). Applied optics, 20(2), 177–184. https://doi.org/10.1364/AO.20.000177 ","category":"page"},{"location":"QuickStart/Center/","page":"Photons at the center","title":"Photons at the center","text":"[2]: Kirk, J. T. O. (1981). Monte Carlo procedure for simulating the penetration of light into natural waters. In Technical paper - Commonwealth Scientific and Industrial Research Organization (Vol. 36).","category":"page"},{"location":"module/refraction/#Refraction","page":"Refraction","title":"Refraction","text":"","category":"section"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"To calculate the refraction of the photons between two medium: air and water, OceanLight.jl expands the Snell's Law into three dimension spherical coordinate, with theta_t denotes the transmission angle beneath the surface, and varphi denotes the azimuth angle. In addition to the photons' path, OceanLight.jl calculates the fraction of light that is being reflected back to the air side, via Fresnel reflectance. ","category":"page"},{"location":"module/refraction/#Snell's-Law","page":"Refraction","title":"Snell's Law","text":"","category":"section"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"The angle of reflection describes through the vector analysis, [1]","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"theta_r = cos^-1hatxicdothatn","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"When our incoming photon is directly downward: hatxi=beginbmatrix001endbmatrix and the normal vector can be defined by hatn=dfrac1sqrt1+left(eta_xright)^2+left(eta_yright)^2left(-eta_xhati-eta_yhatj+hatkright) When, eta_x is the partial derivative the partial derivative of eta with respect to x: dfracpartialetapartial x and eta_y is the partial derivative the partial derivative of eta with respect to y: dfracpartialetapartial y","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"Therefore, the angle of reflection, in this module, can be described by ","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"theta_r = cos^-1left(frac1sqrt1+left(eta_xright)^2+left(eta_yright)^2right)","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"The angle of transmission can be described by Snell's Law,","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"theta_t = sin^-1left(frac1n_wsintheta_rright)","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"Substitute the theta_r that we found above. ","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"theta_t = sin^-1left(frac1n_wsqrtfracleft(eta_xright)^2+left(eta_yright)^21+left(eta_xright)^2+left(eta_yright)^2right)","category":"page"},{"location":"module/refraction/#Fresnel-reflectance","page":"Refraction","title":"Fresnel reflectance","text":"","category":"section"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"In our package, we calculate the energy proportion of the light ray that being transmitted to the water, but first we identify the amplitude transmission coefficient or the ratio between electric field amplitude of the transmitted light ray to the intirial light ray. [2]","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"t_perp = left(fracE_tE_0right)_perp = frac2sin(theta_t)cos(theta_r)sin(theta_t+theta_r)","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"t_parallel = left(fracE_tE_0right)_parallel = frac2sin(theta_t)cos(theta_r)sin(theta_t+theta_r)cos(theta_r-theta_t)","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"When t_perp is corresponding to the amplitude transmission coefficient of the light ray in which the electric field, that constitute the electro magnetic wave, perpendicular to the plane-of-incident , and t_parallel is corresponding to the amplitude transmission coefficient of the light ray in which the electric field, that constitute the electro magnetic wave, parallels to the plane-of-incident.","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"The intensity of the light is proportional to the square of the amplitude, I propto E^2.  All conceivable azimuths of waves that are polarized combine to form natural or unpolarized light. Each wave can be broken down into its constituent parts. Each component will have an equal amount due to symmetry. Then, half of the amplitude transmission coefficient yields the transmission coefficient of a surface in natural light. [3]","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"t = fracI_tI_0 = frac12leftleftfrac2sin(theta_t)cos(theta_r)sin(theta_r+theta_t)right^2+leftfrac2sin(theta_t)cos(theta_r)sin(theta_r+theta_t)cos(theta_r-theta_t)right^2right","category":"page"},{"location":"module/refraction/#Result","page":"Refraction","title":"Result","text":"","category":"section"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"From the principle of least time, the path in which light travels is the path that can traveled in the least time. Hence, the incident, transmitted light ray, and the normal vector to the water surface lie in the same plane. The normal vector to the plane can be described by the cross product between incident light ray and normal vector to the water surface. When the light ray travels downward, along the z-axis, the z-axis lies on the plane, and hence, the plane is perpendicular to the xy plane. The transmitted light ray lies on the opposite side of the normal vector to the water surface. The normal vector to the water surface can be described by, hatn_xy=frac1sqrteta_x^2+eta_y^2beginbmatrix-eta_x-eta_y0endbmatrix`, and the angle of this vector to the x-axis is, ","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"phi = arccosfraceta_xsqrt(eta_x)^2+(eta_y)^2","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"The range for arccos function is 0pi, however, our expected azimuthal angle can span from 02pi. Hence, in order to find the azimuthal angle of the transmitted light ray, we need to consider every possible case of eta_x and eta_y.","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"When eta_x is equal to zero, the possible value for phi is either fracpi2 or frac3pi2, and the value would be determined by eta_y.","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"When eta_y is positive, the normal vector to the water surface hatn lies on either the first or second quadrant, and the azimuthal angle of transmitted light ray would lie on either third or fourth qudrant. Therfore, ","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"varphi = pi+arccosfraceta_xsqrt(eta_x)^2+(eta_y)^2","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"When eta_y is negative, the normal vector to the water surface hatn lies on either the third or fourth quadrant, and the azimuthal angle of transmitted light ray would lie on either first or second qudrant. Therfore, ","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"varphi = pi-arccosfraceta_xsqrt(eta_x)^2+(eta_y)^2","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"The result azimuthal angle of transmitted ray can be described by,","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"varphi = left\nbeginarrayll\npi+arccosleft(fraceta_xsqrt(eta_x)^2+(eta_y)^2right)  textfor  eta_y  0 10pt\npi-arccosleft(fraceta_xsqrt(eta_x)^2+(eta_y)^2right)  textfor  eta_y  0\nendarray\nright","category":"page"},{"location":"module/refraction/#Reference","page":"Refraction","title":"Reference","text":"","category":"section"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"[1]: Mobley, C. (1994). Across the Surface. Light and Water: Radiative Transfer in Natural Waters (pp. 155-157). Academic Press. ","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"[2]: Hecht, E. (2001). The Propagation of Light. Optics (pp. 113-115). Addison-Wesley. ","category":"page"},{"location":"module/refraction/","page":"Refraction","title":"Refraction","text":"[3]: Sears, F.W. (1949). Polarization Optics (pp. 173-174). Addison-Wesley","category":"page"},{"location":"contribute/#Contributors-Guide","page":"Contributor's guide","title":"Contributors Guide","text":"","category":"section"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"Thank you for considering contributions to OceanLight! We hope this guide helps.","category":"page"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"Feel free to ask us questions and chat with us at any time about any topic at all by:","category":"page"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"Opening a GitHub issue","category":"page"},{"location":"contribute/#Creating-issues","page":"Contributor's guide","title":"Creating issues","text":"","category":"section"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"The simplest way to contribute to OceanLight is to create or comment on issues.","category":"page"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"The most useful bug reports:","category":"page"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"Provide an explicit code snippet –- not just a link –- that reproduces the bug in the latest tagged version of OceanLight. This is sometimes called the \"minimal working example\". Reducing bug-producing code to a minimal example can dramatically decrease the time it takes to resolve an issue.\nPaste the entire error received when running the code snippet, even if it's unbelievably long.\nUse triple backticks (e.g., ```some_code; and_some_more_code;```) to enclose code snippets, and other markdown formatting syntax to make your issue easy and quick to read.\nReport the OceanLight version, Julia version, machine (especially if using a GPU) and any other possibly useful details of the computational environment in which the bug was created.","category":"page"},{"location":"contribute/#But-I-want-to-*code*!","page":"Contributor's guide","title":"But I want to code!","text":"","category":"section"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"New users help write OceanLight code and documentation by forking the OceanLight repository, using git to edit code and docs, and then creating a pull request. Pull requests are reviewed by OceanLight collaborators.\nA pull request can be merged once it is reviewed and approved by collaborators. If the pull request author has write access, they have the responsibility of merging their pull request. Otherwise, OceanLight.jl collaborators will execute the merge with permission from the pull request author.\nNote: for small or minor changes (such as fixing a typo in documentation), the GitHub editor is super useful for forking and opening a pull request with a single click.\nWrite your code with love and care. In particular, conform to existing OceanLight style and formatting conventions. For example, we love verbose and explicit variable names, use TitleCase for types, snake_case for objects, and always.put.spaces.after.commas. For formatting decisions we loosely follow the YASGuide. It's worth few extra minutes of our time to leave future generations with well-written, readable code.","category":"page"},{"location":"contribute/#What-is-a-\"collaborator\"-and-how-can-I-become-one?","page":"Contributor's guide","title":"What is a \"collaborator\" and how can I become one?","text":"","category":"section"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"Collaborators have permissions to review pull requests and status allows a contributor to review pull requests in addition to opening them. Collaborators can also create branches in the main OceanLight repository.\nWe ask that new contributors try their hand at forking OceanLight, and opening and merging a pull request before requesting collaborator status.","category":"page"},{"location":"contribute/#What's-a-good-way-to-start-developing-OceanLight?","page":"Contributor's guide","title":"What's a good way to start developing OceanLight?","text":"","category":"section"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"Try to run OceanLight and play around with it. If you run into any problems or find it difficult to use or understand, please open an issue!\nWrite up an example or tutorial on how to do something useful with OceanLight, like how to set up a new configuration.\nImprove documentation or comments if you found something hard to use.\nImplement a new feature if you need it to use OceanLight.","category":"page"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"If you're interested in working on something, let us know by commenting on existing issues or  by opening a new issue. This is to make sure no one else is working on the same issue and so  we can help and guide you in case there is anything you need to know beforehand.","category":"page"},{"location":"contribute/#Ground-Rules","page":"Contributor's guide","title":"Ground Rules","text":"","category":"section"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"Each pull request should consist of a logical collection of changes. You can include multiple bug fixes in a single pull request, but they should be related. For unrelated changes, please submit multiple pull requests.\nDo not commit changes to files that are irrelevant to your feature or bugfix (eg: .gitignore).\nBe willing to accept criticism and work on improving your code; we don't want to break other users' code, so care must be taken not to introduce bugs. We discuss pull requests and keep working on them until we believe we've done a good job.\nBe aware that the pull request review process is not immediate, and is generally proportional to the size of the pull request.","category":"page"},{"location":"contribute/#Reporting-a-bug","page":"Contributor's guide","title":"Reporting a bug","text":"","category":"section"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"The easiest way to get involved is to report issues you encounter when using OceanLight or by requesting something you think is missing.","category":"page"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"Head over to the issues page.\nSearch to see if your issue already exists or has even been solved previously.\nIf you indeed have a new issue or request, click the \"New Issue\" button.\nPlease be as specific as possible. Include the version of the code you were using, as well as what operating system you are running. The output of Julia's versioninfo() and ] status is helpful to include. Try your best to include a complete, \"minimal working example\" that reproduces the issue.","category":"page"},{"location":"contribute/#Setting-up-your-development-environment","page":"Contributor's guide","title":"Setting up your development environment","text":"","category":"section"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"Install Julia on your system.\nInstall git on your system if it is not already there (install XCode command line tools on a Mac or git bash on Windows).\nLogin to your GitHub account and make a fork of the OceanLight repository by clicking the \"Fork\" button.\nClone your fork of the OceanLight repository (in terminal on Mac/Linux or git shell/ GUI on Windows) in the location you'd like to keep it.\ngit clone https://github.com/haoboatlab/OceanLight.jl.git\nNavigate to that folder in the terminal or in Anaconda Prompt if you're on Windows.\nConnect your repository to the upstream (main project).\ngit remote add OceanLight https://github.com/haoboatlab/OceanLight.jl.git\nCreate the development environment by opening Julia via julia --project then typing in ] instantiate. This will install all the dependencies in the Project.toml file.\nYou can test to make sure OceanLight works by typing in ] test. Doing so will run all the tests (and this can take a while).","category":"page"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"Your development environment is now ready!","category":"page"},{"location":"contribute/#Pull-Requests","page":"Contributor's guide","title":"Pull Requests","text":"","category":"section"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"We follow the ColPrac guide for collaborative practices. We ask that new contributors read that guide before submitting a pull request.","category":"page"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"Changes and contributions should be made via GitHub pull requests against the main branch.","category":"page"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"When you're done making changes, commit the changes you made. Chris Beams has written a  guide on how to write good commit messages.","category":"page"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"When you think your changes are ready to be merged into the main repository, push to your fork and submit a pull request.","category":"page"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"Working on your first Pull Request? You can learn how from this free video series How to Contribute to an Open Source Project on GitHub, Aaron Meurer's tutorial on the git workflow, or the guide “How to Contribute to Open Source\".","category":"page"},{"location":"contribute/#Documentation","page":"Contributor's guide","title":"Documentation","text":"","category":"section"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"Now that you've made your awesome contribution, it's time to tell the world how to use it. Writing documentation strings is really important to make sure others use your functionality properly. Didn't write new functions? That's fine, but be sure that the documentation for the code you touched is still in great shape. It is not uncommon to find some strange wording or clarification that you can take care of while you are here.","category":"page"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"You can preview how the Documentation will look like after merging by building the documentation  locally. From the main directory of your local repository call","category":"page"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"JULIA_DEBUG=Documenter julia --project=docs/ docs/make.jl","category":"page"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"and then open docs/build/index.html in your favorite browser. Providing the environment variable  JULIA_DEBUG=Documenter will provide with more information in the documentation build process and thus help figuring out a potential bug.","category":"page"},{"location":"contribute/#Credits","page":"Contributor's guide","title":"Credits","text":"","category":"section"},{"location":"contribute/","page":"Contributor's guide","title":"Contributor's guide","text":"This contributor's guide is heavily based on the excellent OceanBioMe contributors guide and Oceananigans contributors guide which in turn is based on the MetPy contributor's guide.","category":"page"},{"location":"module/Parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"module/Parameters/#Coordinate-system-and-notation","page":"Parameters","title":"Coordinate system and notation","text":"","category":"section"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"OceanLight.jl is formulated in the spherical system hatzeta = (thetaphi), where polar angle theta is measured from the direction of hatz and the azimuthal ange phi is measured positive counter clockwise from hatx, when looking toward the origin along hatz. Let hatxi denoted a unit vector pointing in the desired direction, when hatxi=left(xi_xxi_yxi_zright), and becasue hatxi is of unit length, its component satisfy hatxi_x^2+hatxi_y^2+hatxi_z^2=1. [1] Therefore, ","category":"page"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"hatxi = beginbmatrix sin(theta)cos(phi) sin(theta)sin(phi) cos(theta) endbmatrix","category":"page"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"To simplify the term above, we simplify hatxi by using the cosine parameter.","category":"page"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"hatxi = beginbmatrixmu_x mu_y mu_z endbmatrix = beginbmatrixsin(theta)cos(phi) sin(theta)sin(phi) cos(theta) endbmatrix ","category":"page"},{"location":"module/Parameters/#Local-coordinate-system","page":"Parameters","title":"Local coordinate system","text":"","category":"section"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"When we calculate for the scattering direction, our result is in the local coordination system (hat(theta)hat(phi)hat(r)), when radial unit vector hat(r) is the same initial direction of photons before scattering hatxi, the azimuthal unit vector hat(phi) is defined by the cross product of the ocean coordinate system hatz and the incident vector's direction hatphi=frachatztimeshatrhatztimeshatr, and polar unit vector is given by hattheta=hatphitimeshatr.  Therefore, the unit vector of the scattered direction of photons hatxi_s can be described in the local coordination system (hat(theta)hat(phi)hat(r)) as,","category":"page"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"hatxi_(s) = beginbmatrix sin(theta_s)cos(phi_s) sin(theta_s)sin(phi_s) cos(theta_s) endbmatrix","category":"page"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"when, theta_s and phi_s is polar angle and azimuthal angle in relative to the local coordinate system (hat(theta)hat(phi)hat(r)). ","category":"page"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"To change from the local coordinate system to the cartesian coordination in the global system, we multiply hatxi_(s) by the basis of our local coordinate system.","category":"page"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"beginbmatrix mu_x mu_y mu_z endbmatrix = beginbmatrixhattheta  hatphi  hatr endbmatrixbeginbmatrixhatxi_(s)endbmatrix","category":"page"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"And, after we do the cross product and substitute hatxi_(s). ","category":"page"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"beginbmatrix mu_x mu_y mu_z endbmatrix = beginbmatrixfracmu_xmu_zsqrt1-mu_z^2-fracmu_ysqrt1-mu_z^2mu_xfracmu_ymu_zsqrt1-mu_z^2fracmu_xsqrt1-mu_z^2mu_y-sqrt1-mu_z^20mu_z endbmatrixbeginbmatrix sin(theta_s)cos(phi_s) sin(theta_s)sin(phi_s) cos(theta_s) endbmatrix","category":"page"},{"location":"module/Parameters/#Reference","page":"Parameters","title":"Reference","text":"","category":"section"},{"location":"module/Parameters/","page":"Parameters","title":"Parameters","text":"[1]: Mobley, C. (2021). Light and Radiometry. In A Ocean Optics Web Book. https://www.oceanopticsbook.info","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Kirk, J. T. O. (1981). Monte Carlo procedure for simulating the penetration of light into natural waters. In Technical paper - Commonwealth Scientific and Industrial Research Organization (Vol. 36).","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Petzold, T. J. (1972). Volume Scattering Functions for Selected Ocean Waters. UC San Diego: Scripps Institution of Oceanography. Retrieved from https://escholarship.org/uc/item/73p3r43q","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Mobley, C. (2021). Light and Radiometry. In A Ocean Optics Web Book. https://www.oceanopticsbook.info","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Mobley, C. (1994). Monte Carlo Methods. Light and Water: Radiative Transfer in Natural Waters (pp. 321-326). Academic Press. ","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Mobley, C. (1994). Across the Surface. Light and Water: Radiative Transfer in Natural Waters (pp. 155-157). Academic Press. ","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Hecht, E. (2001). The Propagation of Light. Optics (pp. 113-115). Addison-Wesley. ","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Sears, F.W. (1949). Polarization Optics (pp. 173-174). Addison-Wesley","category":"page"},{"location":"Simulation/Exporting/#Exporting-data","page":"Exporting data","title":"Exporting data","text":"","category":"section"},{"location":"Simulation/Exporting/","page":"Exporting data","title":"Exporting data","text":"Once the OceanLight.jl simulation completes, our solution grid field can be accessed from variable ed. ","category":"page"},{"location":"Simulation/Exporting/#Periodic-boundary-condition","page":"Exporting data","title":"Periodic boundary condition","text":"","category":"section"},{"location":"Simulation/Exporting/","page":"Exporting data","title":"Exporting data","text":"Before accessing the data, OceanLight.jl offers a function in which applying Periodic Boundary Condition on the solution fied ed.","category":"page"},{"location":"Simulation/Exporting/","page":"Exporting data","title":"Exporting data","text":"applybc!(ed::Array{<:Float64,3},p::Param)","category":"page"},{"location":"Simulation/Exporting/#OceanLight.applybc!-Tuple{Array{<:Float64, 3}, Param}","page":"Exporting data","title":"OceanLight.applybc!","text":"applybc!(ed::Array{<:Float64,3},p::Param)\n\nApplying the periodic boundary condition on our irradiance output grid ed if kbc sets to 1 \n\n\n\n\n\n","category":"method"},{"location":"Simulation/Exporting/#Exporting-data-to-HDF-file","page":"Exporting data","title":"Exporting data to HDF file","text":"","category":"section"},{"location":"Simulation/Exporting/","page":"Exporting data","title":"Exporting data","text":"Our data can be exported to .h5 file, with 3 modes: 2D, 3D, and full.  In 2D mode, .h5 file will store the statistic of our irradiance field solution; storing mean μ, variance σ, and cv cv, and the 2 dimenstion cross-section of our solution: xz, yz, and xy. ","category":"page"},{"location":"Simulation/Exporting/","page":"Exporting data","title":"Exporting data","text":"If specified 3D mode, in addition to the data from 2D mode, OceanLight.jl will stored the ed solution. ","category":"page"},{"location":"Simulation/Exporting/","page":"Exporting data","title":"Exporting data","text":"If specified full mode, in addition to the data from 3D mode, OceanLight.jl will stored the physical coordination of the ed solution. ","category":"page"},{"location":"Simulation/Exporting/","page":"Exporting data","title":"Exporting data","text":"exported(ed::Array{<:Real,3},η::Array{<:Real,2},p::Param,\n                  fname::String,mode=\"2D\"::String,nk=0::Int64)","category":"page"},{"location":"Simulation/Exporting/#OceanLight.exported","page":"Exporting data","title":"OceanLight.exported","text":"exported(ed::Array{<:Real,3},η::Array{<:Real,2},p::Param,\n              fname::String,mode=\"2D\"::String,nk=0::Int64)\n\nexported the irradiance data into fname.h5 file. \n\nThere are 3 modes of exporting the data: 2D, 3D, and full. If not specified the mode will automatically set to 2D. \n\n\n\n\n\n","category":"function"},{"location":"Simulation/AirWaveInteract/#Air-water-interaction","page":"Air-Water Interaction","title":"Air-water interaction","text":"","category":"section"},{"location":"Simulation/AirWaveInteract/","page":"Air-Water Interaction","title":"Air-Water Interaction","text":"This section describes the function that can be used for the light interaction between the atmosphere and water. This section can be skipped entirely, if the simulation only considered the light within the water medium.","category":"page"},{"location":"Simulation/AirWaveInteract/","page":"Air-Water Interaction","title":"Air-Water Interaction","text":"To setup the stage for light refraction, the data of water surface distribution is needed: water elevation eta, the slope in x direction eta_x = fracpartial etapartial x and y direction eta_y = fracpartial etapartial y. OceanLight.jl offers random wave distribution or input in .h5 format. ","category":"page"},{"location":"Simulation/AirWaveInteract/#Setting-random-water-surface-distribution","page":"Air-Water Interaction","title":"Setting random water surface distribution","text":"","category":"section"},{"location":"Simulation/AirWaveInteract/","page":"Air-Water Interaction","title":"Air-Water Interaction","text":"setwave!(η::Array{<:Float64,2},ηx::Array{<:Float64,2},ηy::Array{<:Float64,2},rms::Float64,p::Param)","category":"page"},{"location":"Simulation/AirWaveInteract/#OceanLight.setwave!-Tuple{Matrix{<:Float64}, Matrix{<:Float64}, Matrix{<:Float64}, Float64, Param}","page":"Air-Water Interaction","title":"OceanLight.setwave!","text":"setwave!(η::Array{<:Float64,2},ηx::Array{<:Float64,2},ηy::Array{<:Float64,2},rms::Float64,p::Param)\n\nGiving the value to the existed wave surface distribution grid\n\nArguments\n\nη::Array{<:Float64,2}: water surface elevation.\nηx::Array{<:Float64,2}: partial derivative of water surface elevation in x direction.\nηy::Array{<:Float64,2}: partial derivative of water surface elevation in y direction.\nrms::Float64: random number.\np::Param: simulation parameters.\n\n\n\n\n\n","category":"method"},{"location":"Simulation/AirWaveInteract/#Importing-water-surface-distribution-data","page":"Air-Water Interaction","title":"Importing water surface distribution data","text":"","category":"section"},{"location":"Simulation/AirWaveInteract/","page":"Air-Water Interaction","title":"Air-Water Interaction","text":"readdata(datdir::String,fname::String,n::Tuple{<:Int64,<:Int64},pexy::Tuple{<:Float64,<:Float64})","category":"page"},{"location":"Simulation/AirWaveInteract/#OceanLight.readdata-Tuple{String, String, Tuple{Int64, Int64}, Tuple{Float64, Float64}}","page":"Air-Water Interaction","title":"OceanLight.readdata","text":"readdata(datdir::String,fname::String,n::Tuple{<:Int64,<:Int64},pexy::Tuple{<:Float64,<:Float64})\n\nReading the wave surface distribution data (surface elevation η and partial derivative of it in x and y ηx and ηy) from the .h5 file, given the directory datdir and the file name fname\n\n\n\n\n\n","category":"method"},{"location":"Simulation/AirWaveInteract/","page":"Air-Water Interaction","title":"Air-Water Interaction","text":"The water surface distribution data may or may not match the input irradiance field. Hece, OceanLight.jl interpolates the value eta, eta_x, and eta_y, to match the corresponding irradiance field. ","category":"page"},{"location":"Simulation/AirWaveInteract/","page":"Air-Water Interaction","title":"Air-Water Interaction","text":"convertwave!(η::Array{<:Float64,2},ηx::Array{<:Float64,2},ηy::Array{<:Float64,2},\n                      η0::Array{<:AbstractFloat,2},ηx0::Array{<:AbstractFloat,2},ηy0::Array{<:AbstractFloat,2},kbc=0::Int64)","category":"page"},{"location":"Simulation/AirWaveInteract/#OceanLight.convertwave!","page":"Air-Water Interaction","title":"OceanLight.convertwave!","text":"convertwave!(η, ηx, ηy, η0, ηx0, ηy0, kbc)\n\nConvert the surface wave geometry η0, ηx0, ηy0 to  η, ηx, ηy with the same size as irradiance field.  Can be used for nonperiodic BCkbc=1 (no interpolation) or periodic BC kbc=0 (interpolation using FFT)\n\n\n\n\n\n","category":"function"},{"location":"Simulation/AirWaveInteract/#Refraction","page":"Air-Water Interaction","title":"Refraction","text":"","category":"section"},{"location":"Simulation/AirWaveInteract/","page":"Air-Water Interaction","title":"Air-Water Interaction","text":"interface!(xpb::Array{<:Float64,2},ypb::Array{<:Float64,2},zpb::Array{<:Float64,2},\n                    θ::Array{<:Float64,2},ϕ::Array{<:Float64,2},fres::Array{<:Float64,2},\n                    η::Array{<:Float64,2},ηx::Array{<:Float64,2},ηy::Array{<:Float64,2},p::Param)","category":"page"},{"location":"Simulation/AirWaveInteract/#OceanLight.interface!-Tuple{Matrix{<:Float64}, Matrix{<:Float64}, Matrix{<:Float64}, Matrix{<:Float64}, Matrix{<:Float64}, Matrix{<:Float64}, Matrix{<:Float64}, Matrix{<:Float64}, Matrix{<:Float64}, Param}","page":"Air-Water Interaction","title":"OceanLight.interface!","text":"interface!(xpb::Array{<:Float64,2},ypb::Array{<:Float64,2},zpb::Array{<:Float64,2},\n                θ::Array{<:Float64,2},ϕ::Array{<:Float64,2},fres::Array{<:Float64,2},\n                η::Array{<:Float64,2},ηx::Array{<:Float64,2},ηy::Array{<:Float64,2},p::Param)\n\nCalculate the reflection and refraction of the photon or light ray that transmit from the atmosphere to the water.\n\nArguments\n\nxpb::Array{<:Float64,2}: initial x coordination of the photon.\nypb::Array{<:Float64,2}: initial y coordination of the photon.\nzpb::Array{<:Float64,2}: initial z coordination of the photon.\nθ::Array{<:Float64,2}: angle of the light ray relative to the z axis: polar angle.\nϕ::Array{<:Float64,2}: angle of the light ray relative to the x axis: azimuthal angle.\nfres::Array{<:Float64,2}: fresnel coefficient or fractional transmission for unpolarized light\nη::Array{<:Float64,2}: water surface elevation.\nηx::Array{<:Float64,2}: partial derivative of water surface elevation in x direction.\nηy::Array{<:Float64,2}: partial derivative of water surface elevation in y direction.\np::Param: simulation parameters.\n\n\n\n\n\n","category":"method"},{"location":"Simulation/ModelSetup/#Model-setup","page":"Model Setup","title":"Model setup","text":"","category":"section"},{"location":"Simulation/ModelSetup/","page":"Model Setup","title":"Model Setup","text":"OceanLight.jl simulation reads all required variable from the struct param. The description on how to generate and setup the model is described below in this section.  ","category":"page"},{"location":"Simulation/ModelSetup/#Input-variable","page":"Model Setup","title":"Input variable","text":"","category":"section"},{"location":"Simulation/ModelSetup/","page":"Model Setup","title":"Model Setup","text":"OceanLight.jl accepts and reads the input variables from .yml file. The structure on what variable to includes is shown below. ","category":"page"},{"location":"Simulation/ModelSetup/","page":"Model Setup","title":"Model Setup","text":"writeparams(data::Dict,fname=\"light.yml\"::String)","category":"page"},{"location":"Simulation/ModelSetup/#OceanLight.writeparams","page":"Model Setup","title":"OceanLight.writeparams","text":"writeparams(data::Dict,fname=\"light.yml\"::String)\n\nReplace the data in the yml file fname to the new dictionary data. \n\nIf fname is unspecified, use light.yml as the default file name.\n\n\n\n\n\n","category":"function"},{"location":"Simulation/ModelSetup/","page":"Model Setup","title":"Model Setup","text":"This function only read the dict format. Hence, we first need to rearrange into dict format, before we can called the function writeparams(). ","category":"page"},{"location":"Simulation/ModelSetup/","page":"Model Setup","title":"Model Setup","text":"# irradiance\nnz = 200\ndz = 1\nnxe = 512\nnye = 512\nnum = 31\nztop = 10\n# photon\nnphoton = 100000\nkr = 10\nnxp = 512\nkbc = 0\nb = 0.006\nnyp = 512\na = 0.007\n# wave\npey = 0.07853981633974483\nnxeta = 512\nnyeta = 512\npex = 0.07853981633974483\n\ndata=Dict(\"irradiance\"=>Dict(\"nxe\"=>nxe,\"nye\"=>nye,\"nz\"=>nz,\"dz\"=>dz,\"ztop\"=>ztop,\"num\"=>num),\n            \"wave\"=>Dict(\"pex\"=>pex,\"pey\"=>pey,\"nxeta\"=>nxeta,\"nyeta\"=>nyeta),\n            \"photon\"=>Dict(\"nxp\"=>nxp,\"nyp\"=>nyp,\"nphoton\"=>nphoton,\"a\"=>a,\"b\"=>b,\"kr\"=>kr,\"kbc\"=>kbc))","category":"page"},{"location":"Simulation/ModelSetup/#simulation_parameters","page":"Model Setup","title":"Simulation parameters","text":"","category":"section"},{"location":"Simulation/ModelSetup/","page":"Model Setup","title":"Model Setup","text":"OceanLight.jl reads all input variables in .yml format through the function readparams(), and store the values in structure Param. Beside our provided value, it will auto-generate some of the parameters that will be used in the simulation. The list and description of all the values can be accessed below. ","category":"page"},{"location":"Simulation/ModelSetup/","page":"Model Setup","title":"Model Setup","text":"readparams(fname=\"light.yml\"::String)","category":"page"},{"location":"Simulation/ModelSetup/#OceanLight.readparams","page":"Model Setup","title":"OceanLight.readparams","text":"readparams(fname=\"light.yml\")\n\nRead parameters from yml file fname. \n\nIf fname is unspecified, use light.yml as the default file name.\n\n\n\n\n\n","category":"function"},{"location":"Simulation/ModelSetup/","page":"Model Setup","title":"Model Setup","text":"Param    ","category":"page"},{"location":"Simulation/ModelSetup/#OceanLight.Param","page":"Model Setup","title":"OceanLight.Param","text":"struct Param\n\nAll the Parameters and their attributes that will be used in the simulation\n\nnx::Int64: nx = nxe+1 , nxe is the number of energy grid that we will calculate for the energy in x direction\nny::Int64: ny = nye+1 , nye is the number of energy grid that we will calculate for the energy in y direction\nnxe::Int64: number of energy grid that we will calculate for the energy in x direction\nnye::Int64: number of energy grid that we will calculate for the energy in y direction\nnum::Int64: constant always set at 31 based on Measurement from Kirk, 1981 (The number of angle measurement in Kirk paper)\nnz::Int64: number of the layer beneath the sea surface (in z direction) that we will calculate for the irradiance energy\nx::Vector{Float64}: array of all the x corrdination\ny::Vector{Float64}: array of all the y cooradination\nz::Vector{Float64}: array of all the z coordination\npex::Float64: pex is being used in function pdfx or the function to calculate the partial derivative of the surface elevation in x direction\npey::Float64: pey is being used in function pdfx or the function to calculate the partial derivative of the surface elevation in y direction\ndx::Float64: the distance between each grid point in x direction\ndy::Float64: the distance between each grid point in y direction\ndz::Float64: height difference between each layer that we calculate for the irradiance energy (nz)\nztop::Float64: the maximum height above the water surface\nxmin::Float64: minimum x value (always set to 0)\nxmax::Float64: maximum x value equal to multiplication between total number of grid point (nxe) and the distance between each grid point (dx) in x direction\nymin::Float64: minimum y value (always set to 0)\nymax::Float64: maximum y value equal to multiplication between total number of grid point (nye) and the distance between each grid point (dy) in y direction\nxl::Float64: difference between the maximum and minimum value in x direction\nyl::Float64: difference between the maximum and minimum value in y direction\nnxs::Int64: nxs=nxη+1\nnys::Int64: nys=nyη+1\nnxη::Int64: same as nxeta value in the light.yml file: the number of wave grid point in x direction\nnyη::Int64: same as nyeta value in the light.yml file: the number of wave grid point in y direction\nnxp::Int64: number of grid in x direction that the photon will be emitted\nnyp::Int64: number of grid in y direction that the photon will be emitted\nnphoton::Int64: number of photon emitted\nkbc::Int64: setting the mode of boundary condition: kbc=1 (no interpolation) or periodic BC kbc=0 (interpolation using FFT)\na::Float64: absortance coefficient\nb::Float64: scattering coefficient\nkr::Float64: the multiple of sphere detector radius to dz (not being used anywhere in the code)\nddx::Float64: the distance difference in x direction in which we will emit the photon (total length of physical grid xl devided by total number of photon grid nxp)\nddy::Float64: the distance difference in y direction in which we will emit the photon (total length of physical grid yl devided by total number of photon grid nyp)\n\n\n\n\n\n","category":"type"},{"location":"Simulation/WithinWater/#Light-within-water","page":"Light within Water","title":"Light within water","text":"","category":"section"},{"location":"Simulation/WithinWater/","page":"Light within Water","title":"Light within Water","text":"In OceanLight.jl simulation, the scattering photons inside the water medium using the distribution based on Petzold(1972,) in which the value need to be called manually and stored in the variable ph and θps. ","category":"page"},{"location":"Simulation/WithinWater/","page":"Light within Water","title":"Light within Water","text":"phasePetzold()","category":"page"},{"location":"Simulation/WithinWater/#OceanLight.phasePetzold-Tuple{}","page":"Light within Water","title":"OceanLight.phasePetzold","text":"phasePetzold()\n\nreturn 2 arrays: ϕps and θps. \n\nWhen ϕps is the cumulation distribution of scattering angle and θps is the angle between new trajectory and the direction of the photon before scattering corresponding to each ϕps.\n\n\n\n\n\n","category":"method"},{"location":"Simulation/WithinWater/","page":"Light within Water","title":"Light within Water","text":"OceanLight.jl gives the options of constructing the irradiance solution field, depending on the initial condition and the problem one wish to solve. ","category":"page"},{"location":"Simulation/WithinWater/#Single-point-source","page":"Light within Water","title":"Single point source","text":"","category":"section"},{"location":"Simulation/WithinWater/","page":"Light within Water","title":"Light within Water","text":"If the problem is consisted of incoming photons on a single point (i.e. incoming photons only at the center of irradiance field,) the solution grid field is stored directly at ed solution field. ","category":"page"},{"location":"Simulation/WithinWater/","page":"Light within Water","title":"Light within Water","text":"transfer!(ed::Array{<:Float64,3},esol::Array{<:Float64,2},θ::Float64,ϕ::Float64,fres::Float64,ip::Int64,\n                   xpb::Float64,ypb::Float64,zpb::Float64,area::Vector{Float64},interi::Vector{Int64},\n                   interj::Vector{Int64},randrng,η::Array{<:Float64,2},ph::Array{<:Float64,1},\n                   θps::Array{<:Float64,1},p::Param,mode=0::Int64)","category":"page"},{"location":"Simulation/WithinWater/#OceanLight.transfer!","page":"Light within Water","title":"OceanLight.transfer!","text":"transfer!(ed::Array{<:Float64,3},esol::Array{<:Float64,2},θ::Float64,ϕ::Float64,fres::Float64,ip::Int64,\n               xpb::Float64,ypb::Float64,zpb::Float64,area::Vector{Float64},interi::Vector{Int64},\n               interj::Vector{Int64},randrng,η::Array{<:Float64,2},ph::Array{<:Float64,1},\n               θps::Array{<:Float64,1},p::Param,mode=0::Int64)\n\nDoing the Monte Carlo Simulation.\n\nArguments\n\ned::Array{<:Float64,3}: Irradiance solution grid \nesol::Array{<:Float64,2}: Irradiance solution grid for solar mode (under deverlopment)\nθ::Float64: angle of the light ray relative to the z axis: polar angle.\nϕ::Float64: angle of the light ray relative to the x axis: azimuthal angle.\nfres::Float64: fresnel coefficient or fractional transmission for unpolarized light\nip::Int64: current photon's number being simulated (ie. ip ∈ {1, 2,..., nphoton}) \nxpb::Float64: initial x coordination of the photon.\nypb::Float64: initial y coordination of the photon.\nzpb::Float64: initial z coordination of the photon.\narea::Vector{Float64}: 4 values of the area inside a single grid where a photon lands corresponding to: 4 corners of the square grid.\ninteri::Vector{Int64}: x coordination (grid number) of a single grid where a photon lands: from bottom left, bottom right, upper left, and upper right.\ninterj::Vector{Int64}: y coordination (grid number) of a single grid where a photon lands: from bottom left, bottom right, upper left, and upper right.\nrandrng: PRNGs (pseudorandom number generators) exported by the Random package.\nη::Array{<:Float64,2}: water surface elevation.\nph::Array{<:Float64,1}: cumulation distribution of scattering angle (obtained from phasePetzold())\nθps::Array{<:Float64,1}: angle between new trajectory and the direction of the photon before scattering corresponding to each ϕps (obtained from phasePetzold())\np::Param: simulation parameters.\nmode::Int64: mode of different irradinace calculation (under deverlopment)\n\n\n\n\n\n","category":"function"},{"location":"Simulation/WithinWater/#Multiple-points-source","page":"Light within Water","title":"Multiple points source","text":"","category":"section"},{"location":"Simulation/WithinWater/","page":"Light within Water","title":"Light within Water","text":"If the problem is consisted of incoming photons on a multiple point (i.e. incoming photons everywhere on irradiance field,) OceanLight.jl will track each photon individually and stored the irradiance contribution on ed1d with its coordination at edi, edj, and edk, and later, combine into a single solution. ","category":"page"},{"location":"Simulation/WithinWater/","page":"Light within Water","title":"Light within Water","text":"transfer!(ed1d::Array{<:Float64,1},edi::Array{<:Int64,1},edj::Array{<:Int64,1},\n                   edk::Array{<:Int64,1},count::Array{<:Int64,1},esol::Array{<:Float64,2},θ::Float64,ϕ::Float64,fres::Float64,\n                   ip::Int64,xpb::Float64,ypb::Float64,zpb::Float64,randrng,η::Array{<:Float64,2},\n                   ph::Array{<:Float64,1},θps::Array{<:Float64,1},p::Param,mode=0::Int64)","category":"page"},{"location":"Simulation/WithinWater/#OceanLight.transfer!-2","page":"Light within Water","title":"OceanLight.transfer!","text":"transfer!(ed1d::Array{<:Float64,1},edi::Array{<:Int64,1},edj::Array{<:Int64,1},\n               edk::Array{<:Int64,1},count::Array{<:Int64,1},esol::Array{<:Float64,2},θ::Float64,ϕ::Float64,fres::Float64,\n               ip::Int64,xpb::Float64,ypb::Float64,zpb::Float64,randrng,η::Array{<:Float64,2},\n               ph::Array{<:Float64,1},θps::Array{<:Float64,1},p::Param,mode=0::Int64)\n\nDoing the Monte Carlo Simulation.\n\nArguments\n\ned1d::Array{<:Float64,1}: fraction of irradiance that will be assigned to 4 corners of a grid where a photon lands\nedi::Array{<:Int64,1}: x coordination (grid number) of a single grid where a photon lands: from bottom left, bottom right, upper left, and upper right.\nedj::Array{<:Int64,1}: y coordination (grid number) of a single grid where a photon lands: from bottom left, bottom right, upper left, and upper right.\nedk::Array{<:Int64,1}: number of the energy layer that the photons travel, from the top ztop in 1 by 4 array\ncount::Array{<:Int64,1}: (parrallel computing) dummy integer span from 1 to 4 to keep track of the size of the ed1d, edi, edj, edk. \nesol::Array{<:Float64,2}:  Irradiance solution grid for solar mode (under deverlopment)\nθ::Float64: angle of the light ray relative to the z axis: polar angle.\nϕ::Float64: angle of the light ray relative to the x axis: azimuthal angle.\nfres::Float64: fresnel coefficient or fractional transmission for unpolarized light.\nip::Int64: current photon's number being simulated (ie. ip ∈ {1, 2,..., nphoton}) \nxpb::Float64: initial x coordination of the photon.\nypb::Float64: initial y coordination of the photon.\nzpb::Float64: initial z coordination of the photon.\nrandrng: PRNGs (pseudorandom number generators) exported by the Random package\nη::Array{<:Float64,2}: water surface elevation.\nph::Array{<:Float64,1}: cumulation distribution of scattering angle (obtained from phasePetzold())\nθps::Array{<:Float64,1}: angle between new trajectory and the direction of the photon before scattering corresponding to each ϕps (obtained from phasePetzold())\np::Param: simulation parameters.\nmode::Int64: mode of different irradinace calculation (under deverlopment)\n\n\n\n\n\n","category":"function"},{"location":"module/MonteCarlo/#Fundamental-Principle-of-Monte-Carlo-simulation","page":"Monte Carlo Simulation","title":"Fundamental Principle of Monte Carlo simulation","text":"","category":"section"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"The basis of Monte Carlo method lies in the idea that, if we know the probability of occurence of each separate event in a sequence of events, then we can determine the probability that the entire sequence of events will occur [1]. In the simulation of light within the water, each photon, after being transmitted into the water, travels in the medium, interacts with the molecule: absorb and scatter, and either being fully absorbed or reaches the measurement devices. With the multiple photons, we can determine the distribution of the light field. ","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"(Image: Illustration)","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"Illustration of three photons that are being emitted and travel inside the water medium[1]","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"As mentioned above, the separate event that happens for each photon is consisted of travelling some distance in the medium, aborbing, and scattering. All of the events are determined by some probability. Hence, we define the probability distribution of a random number p_Re[1]","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"p_Re (Re) equiv begincases\n1  quad 0 leq Re leq 1 \n0  quad Re  0 cup Re  1\nendcases","category":"page"},{"location":"module/MonteCarlo/#The-optical-path-length","page":"Monte Carlo Simulation","title":"The optical path length","text":"","category":"section"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"After the photon's interaction with the medium or being transmitted into the water, we calculate for the distance the photon would travel before interact with the medium again. The distance r is defined by the equation below, when c is the beam attenuated coefficient or the addition of absorbtance coefficient a and scatterance coefficient b. [1]","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"r=-frac1clnRe","category":"page"},{"location":"module/MonteCarlo/#Sampling-photon-interaction-type","page":"Monte Carlo Simulation","title":"Sampling photon interaction type","text":"","category":"section"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"Once the photon travels for distance r, we then determine how it interacts with the medium; e.g. whether a photon will be absorbed or scattered. This can be done by drawing a random number Re and compare with the albedo of single scattering omega_0 = fracbc, if  Releqomega_0, the photon is being absorbed, and if Regeqomega_0, the photon is being scattered. [1]","category":"page"},{"location":"module/MonteCarlo/#Sampling-scattering-direction","page":"Monte Carlo Simulation","title":"Sampling scattering direction","text":"","category":"section"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"In the scattering event, we will calculate the scattering direction of the photon in the local spherical coordinate with azimuthal angle varphi and polar angle theta. Azimuthal angle varphi is uniformly distribute between 0 and 2pi hence, [1]","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"varphi = 2piRe","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"The angle between new trajectory and the direction before scattering theta is defined by the cumulative distribution, based on the experiment conducted by the Petzold (1972). [2]","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"(Image: CDF)","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"Cumulative Distribution Function of the polar angle or the angle between new trajectory and the direction before scattering theta based on the data from Kirk(1981)[3]","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"Hence, we draw a random number Re and find the corresponding polar angle theta from the cumulative distribution function.","category":"page"},{"location":"module/MonteCarlo/#Reference","page":"Monte Carlo Simulation","title":"Reference","text":"","category":"section"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"[1]: Mobley, C. (1994). Monte Carlo Methods. Light and Water: Radiative Transfer in Natural Waters (pp. 321-326). Academic Press.  ","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"[2]: Petzold, T. J. (1972). Volume Scattering Functions for Selected Ocean Waters. UC San Diego: Scripps Institution of Oceanography. Retrieved from https://escholarship.org/uc/item/73p3r43q","category":"page"},{"location":"module/MonteCarlo/","page":"Monte Carlo Simulation","title":"Monte Carlo Simulation","text":"[3]: Kirk, J. T. O. (1981). Monte Carlo procedure for simulating the penetration of light into natural waters. In Technical paper - Commonwealth Scientific and Industrial Research Organization (Vol. 36).","category":"page"},{"location":"#OceanLight.jl-Documentation","page":"Home","title":"OceanLight.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OceanLight.jl calculates the downwelling irradiance field in the upper ocean. It uses the Monte Carlo method to simulate the trajectories of photons, from their refraction at the air–water interface to specific depths beneath the surface [1] [2]. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Optical oceanography concerns all aspects of light and its interaction with seawater, which are crucial for addressing problems related to physical, biological, and chemical oceanographic processes, such as phytoplankton photosynthesis, biogeochemical cycles, and climate change [3] [4]. However, due to the complex interaction between light and free-surface wave geometry, the irradiance distribution can be highly variable [5] [6], making it difficult to obtain analytical solutions. OceanLight.jl enables physics-based, reproducible simulations of light distribution beneath the ocean surface.","category":"page"},{"location":"#Quick-Install","page":"Home","title":"Quick Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install Julia\nLaunch Julia and type","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"OceanLight\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"After installing, verify that OceanLight works as intended by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.test(\"OceanLight\")","category":"page"},{"location":"#Result","page":"Home","title":"Result","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Center1e8)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simulation of 10^8 Photons at the center of the flat surface. (a) irradiance field on the horizontal plane at 30 mathrmm depth. (b) irradiance field on the horizontal plane at 150 mathrmm depth. (c) irradiance field on the vertical plane at the center","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Wholegrid1000)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simulation of 1000 Photons at the every grid point with observed surface elevation. (a) irradiance field on the horizontal plane at 30 mathrmm depth. (b) irradiance field on the horizontal plane at 150 mathrmm depth. (c) irradiance field on the vertical plane at the center.","category":"page"},{"location":"#Reference","page":"Home","title":"Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Hao, X., & Shen, L. (2022). A novel machine learning method for accelerated modeling of the downwelling irradiance field in the upper ocean. Geophysical Research Letters, 49, e2022GL097769. https://doi.org/10.1029/2022GL097769","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: Kirk, J. T. O. (1981). Monte Carlo procedure for simulating the penetration of light into natural waters. In Technical paper - Commonwealth Scientific and Industrial Research Organization (Vol. 36).","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3]: Dickey, T. D., Kattawar, G. W., & Voss, K. J. (2011). Shedding new light on light in the ocean. Physics Today, 64(4), 44-49.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[4]: Dickey, T., Lewis, M., & Chang, G. (2006). Optical oceanography: recent advances and future directions using global remote sensing and in situ observations. Reviews of geophysics, 44(1).","category":"page"},{"location":"","page":"Home","title":"Home","text":"[5]: Darecki, M., Stramski, D., & Sokólski, M. (2011). Measurements of high‐frequency light fluctuations induced by sea surface waves with an Underwater Porcupine Radiometer System. Journal of Geophysical Research: Oceans, 116(C7).","category":"page"},{"location":"","page":"Home","title":"Home","text":"[6]: Gernez, P., Stramski, D., & Darecki, M. (2011). Vertical changes in the probability distribution of downward irradiance within the near‐surface ocean under sunny conditions. Journal of Geophysical Research: Oceans, 116(C7).","category":"page"}]
}
